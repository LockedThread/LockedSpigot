From 9630a2d445cb7a4f484d3ae5a22e3334979b1837 Mon Sep 17 00:00:00 2001
From: Admin <lockedthreaddev@gmail.com>
Date: Tue, 14 May 2019 20:42:10 -0400
Subject: [PATCH] Attempt 1 fixing predicates


diff --git a/src/main/java/dev/lockedthread/LockedSpigotConfig.java b/src/main/java/dev/lockedthread/LockedSpigotConfig.java
index c9d4d20d2..51459f112 100644
--- a/src/main/java/dev/lockedthread/LockedSpigotConfig.java
+++ b/src/main/java/dev/lockedthread/LockedSpigotConfig.java
@@ -115,6 +115,12 @@ public class LockedSpigotConfig {
     private static boolean signPatchDupe;
     private static int signMaxLength;
 
+    private static boolean tntParticlesEnabled;
+    private static boolean tntAsync;
+
+    private static boolean pistonSoundsEnabled;
+    private static boolean pistonPushEntities;
+
     private static void load() {
         ironGolemCancelFallDamage = getBoolean("irongolem.cancel-falldamage", true);
         ironGolemDropPoppies = getBoolean("irongolem.drop-poppies", false);
@@ -201,6 +207,13 @@ public class LockedSpigotConfig {
         signMaxLength = getInt("signs.max-length", 80);
 
         dispenserParticlesEnabled = getBoolean("dispensers.particles.enabled", false);
+
+        tntAsync = getBoolean("tnt.async", true);
+        tntParticlesEnabled = getBoolean("tnt.particles.enabled", false);
+
+        pistonPushEntities = getBoolean("pistons.push-entities", true);
+        pistonSoundsEnabled = getBoolean("pistons.sounds-enabled", false);
+
         int count = 0;
 
         for (int k = 0; k < 16; ++k) {
@@ -582,4 +595,20 @@ public class LockedSpigotConfig {
         config.addDefault(path, def.name());
         return DyeColor.valueOf(config.getString(path, config.getString(path)));
     }
+
+    public static boolean isTntParticlesEnabled() {
+        return tntParticlesEnabled;
+    }
+
+    public static boolean isTntAsync() {
+        return tntAsync;
+    }
+
+    public static boolean isPistonSoundsEnabled() {
+        return pistonSoundsEnabled;
+    }
+
+    public static boolean isPistonPushEntities() {
+        return pistonPushEntities;
+    }
 }
diff --git a/src/main/java/net/minecraft/server/BlockPiston.java b/src/main/java/net/minecraft/server/BlockPiston.java
index 243b626be..97f0d9368 100644
--- a/src/main/java/net/minecraft/server/BlockPiston.java
+++ b/src/main/java/net/minecraft/server/BlockPiston.java
@@ -1,6 +1,7 @@
 package net.minecraft.server;
 
 import com.google.common.collect.ImmutableList;
+import dev.lockedthread.LockedSpigotConfig;
 import org.bukkit.craftbukkit.block.CraftBlock;
 import org.bukkit.event.block.BlockPistonExtendEvent;
 import org.bukkit.event.block.BlockPistonRetractEvent;
@@ -134,7 +135,9 @@ public class BlockPiston extends Block {
             }
 
             world.setTypeAndData(blockposition, iblockdata.set(BlockPiston.EXTENDED, Boolean.TRUE), 2);
-            world.makeSound((double) blockposition.getX() + 0.5D, (double) blockposition.getY() + 0.5D, (double) blockposition.getZ() + 0.5D, "tile.piston.out", 0.5F, world.random.nextFloat() * 0.25F + 0.6F);
+            if (LockedSpigotConfig.isPistonSoundsEnabled()) {
+                world.makeSound((double) blockposition.getX() + 0.5D, (double) blockposition.getY() + 0.5D, (double) blockposition.getZ() + 0.5D, "tile.piston.out", 0.5F, world.random.nextFloat() * 0.25F + 0.6F);
+            }
         } else if (i == 1) {
             TileEntity tileentity = world.getTileEntity(blockposition.shift(enumdirection));
 
@@ -169,7 +172,9 @@ public class BlockPiston extends Block {
                 world.setAir(blockposition.shift(enumdirection));
             }
 
-            world.makeSound((double) blockposition.getX() + 0.5D, (double) blockposition.getY() + 0.5D, (double) blockposition.getZ() + 0.5D, "tile.piston.in", 0.5F, world.random.nextFloat() * 0.15F + 0.6F);
+            if (LockedSpigotConfig.isPistonSoundsEnabled()) {
+                world.makeSound((double) blockposition.getX() + 0.5D, (double) blockposition.getY() + 0.5D, (double) blockposition.getZ() + 0.5D, "tile.piston.in", 0.5F, world.random.nextFloat() * 0.15F + 0.6F);
+            }
         }
 
         return true;
diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index b87bb023c..77329ed29 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -4,10 +4,14 @@ import com.google.common.base.Predicate;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Queues;
+import gnu.trove.map.hash.TObjectIntHashMap;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftChunk;
 import org.bukkit.craftbukkit.entity.CraftHumanEntity;
+import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.bukkit.craftbukkit.util.UnsafeList;
 import org.bukkit.entity.HumanEntity;
 
 import java.util.*;
@@ -45,7 +49,7 @@ public class Chunk {
     private long u;
     private int v;
     private ConcurrentLinkedQueue<BlockPosition> w;
-    protected gnu.trove.map.hash.TObjectIntHashMap<Class> entityCount = new gnu.trove.map.hash.TObjectIntHashMap<>(); // Spigot
+    protected TObjectIntHashMap<Class> entityCount = new TObjectIntHashMap<>(); // Spigot
     // PaperSpigot start - Asynchronous light updates
     public AtomicInteger pendingLightUpdates = new AtomicInteger();
     public long lightUpdateTime;
@@ -97,31 +101,6 @@ public class Chunk {
     // CraftBukkit start - Neighbor loaded cache for chunk lighting and entity ticking
     private int neighbors = 0x1 << 12;
 
-    public boolean areNeighborsLoaded(final int radius) {
-        switch (radius) {
-            case 2:
-                return this.neighbors == Integer.MAX_VALUE >> 6;
-            case 1:
-                final int mask =
-                        //       x        z   offset          x        z   offset          x         z   offset
-                        (0x1 << (1 * 5 +  1 + 12)) | (0x1 << (0 * 5 +  1 + 12)) | (0x1 << (-1 * 5 +  1 + 12)) |
-                        (0x1 << (1 * 5 +  0 + 12)) | (0x1 << (0 * 5 +  0 + 12)) | (0x1 << (-1 * 5 +  0 + 12)) |
-                        (0x1 << (1 * 5 + -1 + 12)) | (0x1 << (0 * 5 + -1 + 12)) | (0x1 << (-1 * 5 + -1 + 12));
-                return (this.neighbors & mask) == mask;
-            default:
-                throw new UnsupportedOperationException(String.valueOf(radius));
-        }
-    }
-
-    public void setNeighborLoaded(final int x, final int z) {
-        this.neighbors |= 0x1 << (x * 5 + 12 + z);
-    }
-
-    public void setNeighborUnloaded(final int x, final int z) {
-        this.neighbors &= ~(0x1 << (x * 5 + 12 + z));
-    }
-    // CraftBukkit end
-
     public Chunk(World world, int i, int j) {
         this.sections = new ChunkSection[16];
         this.e = new byte[256];
@@ -137,7 +116,7 @@ public class Chunk {
         this.heightMap = new int[256];
 
         for (int k = 0; k < this.entitySlices.length; ++k) {
-            this.entitySlices[k] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
+            this.entitySlices[k] = new UnsafeList(); // Spigot
         }
 
         Arrays.fill(this.f, -999);
@@ -145,7 +124,32 @@ public class Chunk {
 
         // CraftBukkit start
         if (!(this instanceof EmptyChunk)) {
-            this.bukkitChunk = new org.bukkit.craftbukkit.CraftChunk(this);
+            this.bukkitChunk = new CraftChunk(this);
+        }
+    }
+
+    public void setNeighborLoaded(final int x, final int z) {
+        this.neighbors |= 0x1 << (x * 5 + 12 + z);
+    }
+
+    public void setNeighborUnloaded(final int x, final int z) {
+        this.neighbors &= ~(0x1 << (x * 5 + 12 + z));
+    }
+    // CraftBukkit end
+
+    public boolean areNeighborsLoaded(final int radius) {
+        switch (radius) {
+            case 2:
+                return this.neighbors == Integer.MAX_VALUE >> 6;
+            case 1:
+                final int mask =
+                        //       x        z   offset          x        z   offset          x         z   offset
+                        (0x1 << (1 * 5 + 1 + 12)) | (0x1 << (0 * 5 + 1 + 12)) | (0x1 << (-1 * 5 + 1 + 12)) |
+                                (0x1 << (1 * 5 + 0 + 12)) | (0x1 << (0 * 5 + 0 + 12)) | (0x1 << (-1 * 5 + 0 + 12)) |
+                                (0x1 << (1 * 5 + -1 + 12)) | (0x1 << (0 * 5 + -1 + 12)) | (0x1 << (-1 * 5 + -1 + 12));
+                return (this.neighbors & mask) == mask;
+            default:
+                throw new UnsupportedOperationException(String.valueOf(radius));
         }
     }
 
@@ -497,6 +501,7 @@ public class Chunk {
         }
         return Blocks.AIR.getBlockData();
     }
+
     public IBlockData getBlockDataSlow(final BlockPosition blockposition) {
         // PaperSpigot end
         if (this.world.G() == WorldType.DEBUG_ALL_BLOCK_STATES) {
@@ -622,19 +627,19 @@ public class Chunk {
                 TileEntity tileentity;
 
                 if (block1 instanceof IContainer) {
-                    tileentity = this.a(blockposition, Chunk.EnumTileEntityState.CHECK);
+                    tileentity = this.a(blockposition, EnumTileEntityState.CHECK);
                     if (tileentity != null) {
                         tileentity.E();
                     }
                 }
 
                 // CraftBukkit - Don't place while processing the BlockPlaceEvent, unless it's a BlockContainer. Prevents blocks such as TNT from activating when cancelled.
-                if (!this.world.isClientSide && block1 != block  && (!this.world.captureBlockStates || block instanceof BlockContainer)) {
+                if (!this.world.isClientSide && block1 != block && (!this.world.captureBlockStates || block instanceof BlockContainer)) {
                     block.onPlace(this.world, blockposition, iblockdata);
                 }
 
                 if (block instanceof IContainer) {
-                    tileentity = this.a(blockposition, Chunk.EnumTileEntityState.CHECK);
+                    tileentity = this.a(blockposition, EnumTileEntityState.CHECK);
                     if (tileentity == null) {
                         tileentity = ((IContainer) block).a(this.world, block.toLegacyData(iblockdata));
                         this.world.setTileEntity(blockposition, tileentity);
@@ -748,11 +753,9 @@ public class Chunk {
                 return;
             }
         }
-        for ( EnumCreatureType creatureType : EnumCreatureType.values() )
-        {
-            if ( creatureType.a().isAssignableFrom( entity.getClass() ) )
-            {
-                this.entityCount.adjustOrPutValue( creatureType.a(), 1, 1 );
+        for (EnumCreatureType creatureType : EnumCreatureType.values()) {
+            if (creatureType.a().isAssignableFrom(entity.getClass())) {
+                this.entityCount.adjustOrPutValue(creatureType.a(), 1, 1);
             }
         }
         // Spigot end
@@ -787,11 +790,9 @@ public class Chunk {
                 return;
             }
         }
-        for ( EnumCreatureType creatureType : EnumCreatureType.values() )
-        {
-            if ( creatureType.a().isAssignableFrom( entity.getClass() ) )
-            {
-                this.entityCount.adjustValue( creatureType.a(), -1 );
+        for (EnumCreatureType creatureType : EnumCreatureType.values()) {
+            if (creatureType.a().isAssignableFrom(entity.getClass())) {
+                this.entityCount.adjustValue(creatureType.a(), -1);
             }
         }
         // Spigot end
@@ -811,7 +812,7 @@ public class Chunk {
         return !block.isTileEntity() ? null : ((IContainer) block).a(this.world, this.c(blockposition));
     }
 
-    public TileEntity a(BlockPosition blockposition, Chunk.EnumTileEntityState chunk_enumtileentitystate) {
+    public TileEntity a(BlockPosition blockposition, EnumTileEntityState chunk_enumtileentitystate) {
         // CraftBukkit start
         TileEntity tileentity = null;
         if (world.captureBlockStates) {
@@ -823,10 +824,10 @@ public class Chunk {
         // CraftBukkit end
 
         if (tileentity == null) {
-            if (chunk_enumtileentitystate == Chunk.EnumTileEntityState.IMMEDIATE) {
+            if (chunk_enumtileentitystate == EnumTileEntityState.IMMEDIATE) {
                 tileentity = this.i(blockposition);
                 this.world.setTileEntity(blockposition, tileentity);
-            } else if (chunk_enumtileentitystate == Chunk.EnumTileEntityState.QUEUED) {
+            } else if (chunk_enumtileentitystate == EnumTileEntityState.QUEUED) {
                 this.w.add(blockposition);
             }
         } else if (tileentity.x()) {
@@ -858,12 +859,12 @@ public class Chunk {
             // CraftBukkit start
             // PaperSpigot start - Remove invalid mob spawner tile entities
         } else if (this.world.paperSpigotConfig.removeInvalidMobSpawnerTEs && tileentity instanceof TileEntityMobSpawner &&
-                org.bukkit.craftbukkit.util.CraftMagicNumbers.getMaterial(getType(blockposition)) != org.bukkit.Material.MOB_SPAWNER) {
+                CraftMagicNumbers.getMaterial(getType(blockposition)) != org.bukkit.Material.MOB_SPAWNER) {
             this.tileEntities.remove(blockposition);
             // PaperSpigot end
         } else {
             System.out.println("Attempted to place a tile entity (" + tileentity + ") at " + tileentity.position.getX() + "," + tileentity.position.getY() + "," + tileentity.position.getZ()
-                + " (" + org.bukkit.craftbukkit.util.CraftMagicNumbers.getMaterial(getType(blockposition)) + ") where there was no entity tile!");
+                    + " (" + CraftMagicNumbers.getMaterial(getType(blockposition)) + ") where there was no entity tile!");
             System.out.println("Chunk coordinates: " + (this.locX * 16) + "," + (this.locZ * 16));
             new Exception().printStackTrace();
             // CraftBukkit end
@@ -949,7 +950,7 @@ public class Chunk {
         this.q = true;
     }
 
-    public void a(Entity entity, AxisAlignedBB axisalignedbb, List<Entity> list, Predicate<? super Entity> predicate) {
+    public void a(Entity entity, AxisAlignedBB axisalignedbb, List<Entity> list, java.util.function.Predicate<Entity> predicate) {
         int i = MathHelper.floor((axisalignedbb.b - 2.0D) / 16.0D);
         int j = MathHelper.floor((axisalignedbb.e + 2.0D) / 16.0D);
 
@@ -961,7 +962,7 @@ public class Chunk {
                 if (predicate == IEntitySelector.c && inventoryEntityCounts[k] <= 0) continue;
                 for (Entity entity1 : this.entitySlices[k]) {
                     if (entity1.getBoundingBox().b(axisalignedbb) && entity1 != entity) {
-                        if (predicate == null || predicate.apply(entity1)) {
+                        if (predicate.test(entity1)) {
                             list.add(entity1);
                         }
 
@@ -970,7 +971,7 @@ public class Chunk {
                         if (aentity != null) {
                             for (Entity value : aentity) {
                                 entity1 = value;
-                                if (entity1 != entity && entity1.getBoundingBox().b(axisalignedbb) && (predicate == null || predicate.apply(entity1))) {
+                                if (entity1 != entity && entity1.getBoundingBox().b(axisalignedbb) && (predicate.test(entity1))) {
                                     list.add(entity1);
                                 }
                             }
@@ -1000,7 +1001,8 @@ public class Chunk {
         }
         // PaperSpigot end
         for (int k = i; k <= j; ++k) {
-            if (counts != null && counts[k] <= 0) continue; // PaperSpigot - Don't check a chunk if it doesn't have the type we are looking for
+            if (counts != null && counts[k] <= 0)
+                continue; // PaperSpigot - Don't check a chunk if it doesn't have the type we are looking for
 
             for (Entity entity : this.entitySlices[k]) {
                 if (oclass.isInstance(entity) && entity.getBoundingBox().b(axisalignedbb) && (predicate == null || predicate.apply((T) entity))) { // CraftBukkit - fix decompile error // Spigot
@@ -1124,7 +1126,7 @@ public class Chunk {
         while (!this.w.isEmpty()) {
             BlockPosition blockposition = this.w.poll();
 
-            if (this.a(blockposition, Chunk.EnumTileEntityState.CHECK) == null && this.getType(blockposition).isTileEntity()) {
+            if (this.a(blockposition, EnumTileEntityState.CHECK) == null && this.getType(blockposition).isTileEntity()) {
                 TileEntity tileentity = this.i(blockposition);
 
                 this.world.setTileEntity(blockposition, tileentity);
@@ -1434,6 +1436,7 @@ public class Chunk {
 
         IMMEDIATE, QUEUED, CHECK;
 
-        EnumTileEntityState() {}
+        EnumTileEntityState() {
+        }
     }
 }
diff --git a/src/main/java/net/minecraft/server/EntityHorse.java b/src/main/java/net/minecraft/server/EntityHorse.java
index 6dcef1f8b..8de862680 100644
--- a/src/main/java/net/minecraft/server/EntityHorse.java
+++ b/src/main/java/net/minecraft/server/EntityHorse.java
@@ -1,10 +1,11 @@
 package net.minecraft.server;
 
-import com.google.common.base.Predicate;
-import java.util.Iterator;
-import java.util.List;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason;
+import org.bukkit.event.entity.HorseJumpEvent;
 
-import org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason; // CraftBukkit
+import java.util.List;
+import java.util.function.Predicate;
 
 public class EntityHorse extends EntityAnimal implements IInventoryListener {
 
@@ -13,7 +14,7 @@ public class EntityHorse extends EntityAnimal implements IInventoryListener {
             return entity instanceof EntityHorse && ((EntityHorse) entity).cA();
         }
 
-        public boolean apply(Object object) {
+        public boolean test(Object object) {
             return this.a((Entity) object);
         }
     };
@@ -1163,9 +1164,9 @@ public class EntityHorse extends EntityAnimal implements IInventoryListener {
         int i = 0;
         int j;
 
-        if (object instanceof EntityHorse.GroupDataHorse) {
-            j = ((EntityHorse.GroupDataHorse) object).a;
-            i = ((EntityHorse.GroupDataHorse) object).b & 255 | this.getRandom().nextInt(5) << 8;
+        if (object instanceof GroupDataHorse) {
+            j = ((GroupDataHorse) object).a;
+            i = ((GroupDataHorse) object).b & 255 | this.getRandom().nextInt(5) << 8;
         } else {
             if (this.getRandom().nextInt(10) == 0) {
                 j = 1;
@@ -1177,7 +1178,7 @@ public class EntityHorse extends EntityAnimal implements IInventoryListener {
                 i = k | l << 8;
             }
 
-            object = new EntityHorse.GroupDataHorse(j, i);
+            object = new GroupDataHorse(j, i);
         }
 
         this.setType(j);
@@ -1222,7 +1223,7 @@ public class EntityHorse extends EntityAnimal implements IInventoryListener {
                 power = 0.4F + 0.4F * (float) i / 90.0F;
             }
 
-            org.bukkit.event.entity.HorseJumpEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.callHorseJumpEvent(this, power);
+            HorseJumpEvent event = CraftEventFactory.callHorseJumpEvent(this, power);
             if (!event.isCancelled()) {
                 this.bG = true;
                 this.dh();
diff --git a/src/main/java/net/minecraft/server/EntityLiving.java b/src/main/java/net/minecraft/server/EntityLiving.java
index 905c7fe1d..168a1290e 100644
--- a/src/main/java/net/minecraft/server/EntityLiving.java
+++ b/src/main/java/net/minecraft/server/EntityLiving.java
@@ -1,13 +1,14 @@
 package net.minecraft.server;
 
 import com.google.common.base.Function;
-import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import dev.lockedthread.LockedSpigotConfig;
 import net.jafama.FastMath;
 import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.TrigMath;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.entity.LivingEntity;
 import org.bukkit.entity.Vehicle;
@@ -15,6 +16,7 @@ import org.bukkit.event.entity.EntityDamageEvent;
 import org.bukkit.event.entity.EntityDamageEvent.DamageModifier;
 import org.bukkit.event.entity.EntityRegainHealthEvent;
 import org.bukkit.event.vehicle.VehicleExitEvent;
+import org.spigotmc.AsyncCatcher;
 import org.spigotmc.event.entity.EntityDismountEvent;
 
 import java.util.*;
@@ -579,7 +581,7 @@ public abstract class EntityLiving extends Entity {
     }
 
     public void addEffect(MobEffect mobeffect) {
-        org.spigotmc.AsyncCatcher.catchOp("effect add"); // Spigot
+        AsyncCatcher.catchOp("effect add"); // Spigot
         // CraftBukkit start
         if (isTickingEffects) {
             effectsToProcess.add(mobeffect);
@@ -684,7 +686,7 @@ public abstract class EntityLiving extends Entity {
     public void setHealth(float f) {
         // CraftBukkit start - Handle scaled health
         if (this instanceof EntityPlayer) {
-            org.bukkit.craftbukkit.entity.CraftPlayer player = ((EntityPlayer) this).getBukkitEntity();
+            CraftPlayer player = ((EntityPlayer) this).getBukkitEntity();
             // Squeeze
             if (f < 0.0F) {
                 player.setRealHealth(0.0D);
@@ -1484,7 +1486,7 @@ public abstract class EntityLiving extends Entity {
             f3 = 1.0F;
             f2 = (float) FastMath.sqrt((double) f) * 3.0F;
             // CraftBukkit - FastMath -> TrigMath
-            f1 = (float) org.bukkit.craftbukkit.TrigMath.atan2(d1, d0) * 180.0F / 3.1415927F - 90.0F;
+            f1 = (float) TrigMath.atan2(d1, d0) * 180.0F / 3.1415927F - 90.0F;
         }
 
         if (this.az > 0.0F) {
@@ -1644,16 +1646,7 @@ public abstract class EntityLiving extends Entity {
     }
 
     protected void bL() {
-        List list = this.world.a(this, this.getBoundingBox().grow(0.20000000298023224D, 0.0D, 0.20000000298023224D), Predicates.and(IEntitySelector.d, new Predicate() {
-            public boolean a(Entity entity) {
-                return entity.ae();
-            }
-
-            public boolean apply(Object object) {
-                return this.a((Entity) object);
-            }
-        }));
-
+        List list = this.world.a(this, this.getBoundingBox().grow(0.20000000298023224, 0.0, 0.20000000298023224), Predicates.and(IEntitySelector.d, Entity::ae));
         if (this.ad() && !list.isEmpty()) { // Spigot: Add this.ad() condition
             numCollisions -= world.spigotConfig.maxCollisionsPerEntity; // Spigot
             for (Object o : list) {
diff --git a/src/main/java/net/minecraft/server/EntityProjectile.java b/src/main/java/net/minecraft/server/EntityProjectile.java
index ab4b6a68c..dc08329c6 100644
--- a/src/main/java/net/minecraft/server/EntityProjectile.java
+++ b/src/main/java/net/minecraft/server/EntityProjectile.java
@@ -119,13 +119,11 @@ public abstract class EntityProjectile extends Entity implements IProjectile {
 
         if (!this.world.isClientSide) {
             Entity entity = null;
-            List list = this.world.getEntities(this, this.getBoundingBox().a(this.motX, this.motY, this.motZ).grow(1.0D, 1.0D, 1.0D));
+            List<Entity> list = this.world.getEntities(this, this.getBoundingBox().a(this.motX, this.motY, this.motZ).grow(1.0D, 1.0D, 1.0D));
             double d0 = 0.0D;
             EntityLiving entityliving = this.getShooter();
 
-            for (Object o : list) {
-                Entity entity1 = (Entity) o;
-
+            for (Entity entity1 : list) {
                 if (entity1.ad() && (entity1 != entityliving || this.ar >= 5)) {
                     float f = 0.3F;
                     AxisAlignedBB axisalignedbb = entity1.getBoundingBox().grow((double) f, (double) f, (double) f);
diff --git a/src/main/java/net/minecraft/server/EntityTNTPrimed.java b/src/main/java/net/minecraft/server/EntityTNTPrimed.java
index 1117d22b9..63af863e8 100644
--- a/src/main/java/net/minecraft/server/EntityTNTPrimed.java
+++ b/src/main/java/net/minecraft/server/EntityTNTPrimed.java
@@ -1,5 +1,8 @@
 package net.minecraft.server;
 
+import dev.lockedthread.LockedSpigotConfig;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
 import org.bukkit.event.entity.ExplosionPrimeEvent;
 
 public class EntityTNTPrimed extends Entity {
@@ -9,6 +12,12 @@ public class EntityTNTPrimed extends Entity {
     public float yield = 4; // CraftBukkit - add field
     public boolean isIncendiary = false; // CraftBukkit - add field
     public org.bukkit.Location sourceLoc; // PaperSpigot
+    public boolean async;
+    public int potential;
+    public double lastMotX;
+    public double lastMotY;
+    public double lastMotZ;
+    public boolean block;
 
     // PaperSpigot start - TNT entity location API
     public EntityTNTPrimed(World world) {
@@ -18,7 +27,7 @@ public class EntityTNTPrimed extends Entity {
     public EntityTNTPrimed(org.bukkit.Location loc, World world) {
         super(world);
         sourceLoc = loc;
-    // PaperSpigot end
+        // PaperSpigot end
         this.k = true;
         this.setSize(0.98F, 0.98F);
         this.loadChunks = world.paperSpigotConfig.loadUnloadedTNTEntities; // PaperSpigot
@@ -38,9 +47,16 @@ public class EntityTNTPrimed extends Entity {
         this.lastZ = d2;
         this.source = entityliving;
         if (world.paperSpigotConfig.fixCannons) this.motX = this.motZ = 0.0F; // PaperSpigot - Fix cannons
+        this.async = true;
+        this.potential = 1;
+        this.lastMotX = 0.0;
+        this.lastMotY = 0.0;
+        this.lastMotZ = 0.0;
+        this.block = false;
     }
 
-    protected void h() {}
+    protected void h() {
+    }
 
     protected boolean s_() {
         return false;
@@ -51,7 +67,13 @@ public class EntityTNTPrimed extends Entity {
     }
 
     public void t_() {
-        if (world.spigotConfig.currentPrimedTnt++ > world.spigotConfig.maxTntTicksPerTick) { return; } // Spigot
+        this.async();
+        this.lastMotX = this.motX;
+        this.lastMotY = this.motY;
+        this.lastMotZ = this.motZ;
+        if (world.spigotConfig.currentPrimedTnt++ > world.spigotConfig.maxTntTicksPerTick) {
+            return;
+        } // Spigot
         this.lastX = this.locX;
         this.lastY = this.locY;
         this.lastZ = this.locZ;
@@ -83,6 +105,7 @@ public class EntityTNTPrimed extends Entity {
         if (this.fuseTicks-- <= 0) {
             // CraftBukkit start - Need to reverse the order of the explosion and the entity death so we have a location for the event
             // this.die();
+            this.async_respawn();
             if (!this.world.isClientSide) {
                 this.explode();
             }
@@ -90,7 +113,9 @@ public class EntityTNTPrimed extends Entity {
             // CraftBukkit end
         } else {
             this.W();
-            this.world.addParticle(EnumParticle.SMOKE_NORMAL, this.locX, this.locY + 0.5D, this.locZ, 0.0D, 0.0D, 0.0D);
+            if (LockedSpigotConfig.isTntParticlesEnabled()) {
+                this.world.addParticle(EnumParticle.SMOKE_NORMAL, this.locX, this.locY + 0.5D, this.locZ, 0.0D, 0.0D, 0.0D);
+            }
         }
 
     }
@@ -211,4 +236,39 @@ public class EntityTNTPrimed extends Entity {
         return this.inWater;
     }
     // PaperSpigot end
+
+    public void async() {
+        if (LockedSpigotConfig.isTntAsync()) {
+            if (this.async && this.motX == 0.0 && this.motY == 0.0 && this.motZ == 0.0) {
+                final Location etp_location = new Location(Bukkit.getWorld(this.getWorld().getWorld().getName()), this.locX, this.locY, this.locZ);
+                if (!etp_location.getBlock().isEmpty() && !etp_location.getBlock().isLiquid()) {
+                    this.block = true;
+                }
+                for (final Entity entity : this.getBukkitEntity().getLocalTNTEntities()) {
+                    entity.die();
+                    this.potential += ((EntityTNTPrimed) entity).potential;
+                }
+            }
+        }
+    }
+
+    public void async_respawn() {
+        if (LockedSpigotConfig.isTntAsync()) {
+            if (this.potential > 1 && (this.locX != this.lastX || this.locY != this.lastY || this.locZ != this.lastZ || this.block)) {
+                for (int a = 1; a < this.potential; ++a) {
+                    final EntityTNTPrimed etp = new EntityTNTPrimed(new Location(this.getBukkitEntity().getWorld(), this.lastX, this.lastY, this.lastZ), this.getWorld(), this.lastX, this.lastY, this.lastZ, this.getSource());
+                    etp.fuseTicks = 0;
+                    etp.async = false;
+                    etp.potential = 1;
+                    this.world.addEntity(etp);
+                    this.world.entityList.add(this.world.entityList.indexOf(this) + 1, etp);
+                    etp.motX = this.lastMotX;
+                    etp.motY = this.lastMotY;
+                    etp.motZ = this.lastMotZ;
+                }
+                this.potential = 1;
+                this.async = true;
+            }
+        }
+    }
 }
diff --git a/src/main/java/net/minecraft/server/Explosion.java b/src/main/java/net/minecraft/server/Explosion.java
index 2a766a3f4..26e3bebed 100644
--- a/src/main/java/net/minecraft/server/Explosion.java
+++ b/src/main/java/net/minecraft/server/Explosion.java
@@ -6,6 +6,7 @@ import dev.lockedthread.locations.ExplosionLocation;
 import dev.lockedthread.locations.RenderedLocation;
 import dev.lockedthread.regions.LargeRegion;
 import org.bukkit.Location;
+import org.bukkit.World;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.entity.Player;
 import org.bukkit.event.block.BlockExplodeEvent;
@@ -151,7 +152,7 @@ public class Explosion {
             }
         }
         if (this.b) {
-            org.bukkit.World bukkitWorld = this.source.world.getWorld();
+            World bukkitWorld = this.source.world.getWorld();
             List<org.bukkit.block.Block> blockList = new ArrayList<>();
             for (BlockPosition blockPosition : blocks) {
                 org.bukkit.block.Block bblock = explosionInfo.getRegion().getBukkitBlock(blockPosition);
diff --git a/src/main/java/net/minecraft/server/TileEntityHopper.java b/src/main/java/net/minecraft/server/TileEntityHopper.java
index fb9c57265..4eb935fb0 100644
--- a/src/main/java/net/minecraft/server/TileEntityHopper.java
+++ b/src/main/java/net/minecraft/server/TileEntityHopper.java
@@ -3,12 +3,15 @@ package net.minecraft.server;
 import net.jafama.FastMath;
 import net.techcable.tacospigot.HopperHelper;
 import org.bukkit.craftbukkit.entity.CraftHumanEntity;
+import org.bukkit.craftbukkit.inventory.CraftInventoryDoubleChest;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.entity.HumanEntity;
+import org.bukkit.entity.Item;
 import org.bukkit.event.inventory.InventoryMoveItemEvent;
 import org.bukkit.event.inventory.InventoryPickupItemEvent;
 import org.bukkit.inventory.Inventory;
 
+import java.util.ArrayList;
 import java.util.List;
 
 // CraftBukkit start
@@ -21,7 +24,7 @@ public class TileEntityHopper extends TileEntityContainer implements IHopper, IU
     private int g = -1;
 
     // CraftBukkit start - add fields and methods
-    public List<HumanEntity> transaction = new java.util.ArrayList<>();
+    public List<HumanEntity> transaction = new ArrayList<>();
     private int maxStack = MAX_STACK;
 
     public ItemStack[] getContents() {
@@ -244,73 +247,65 @@ public class TileEntityHopper extends TileEntityContainer implements IHopper, IU
         return true;
     }
 
-    private boolean r() {
-        // TacoSpigot start - Don't use inefficient H() which does another bounding box search
-        IInventory iinventory = HopperHelper.getInventory(getWorld(), getPosition().shift(BlockHopper.b(this.u())));
-        // TacoSpigot end
-
-        if (iinventory == null) {
-            return false;
-        } else {
-            EnumDirection enumdirection = BlockHopper.b(this.u()).opposite();
+    private static boolean a(IHopper ihopper, IInventory iinventory, int i, EnumDirection enumdirection) {
+        ItemStack itemstack = iinventory.getItem(i);
 
-            if (this.a(iinventory, enumdirection)) {
-                return false;
-            } else {
-                for (int i = 0; i < this.getSize(); ++i) {
-                    if (this.getItem(i) != null) {
-                        ItemStack itemstack = this.getItem(i).cloneItemStack();
-                        // ItemStack itemstack1 = addItem(iinventory, this.splitStack(i, 1), enumdirection);
+        if (itemstack != null && b(iinventory, itemstack, i, enumdirection)) {
+            ItemStack itemstack1 = itemstack.cloneItemStack();
+            // ItemStack itemstack2 = addItem(ihopper, iinventory.splitStack(i, 1), (EnumDirection) null);
+            // CraftBukkit start - Call event on collection of items from inventories into the hopper
+            CraftItemStack oitemstack = CraftItemStack.asCraftMirror(iinventory.splitStack(i, ihopper.getWorld().spigotConfig.hopperAmount)); // Spigot
+            // TacoSpigot start - add an option to turn of InventoryMoveItemEvent
+            final org.bukkit.inventory.ItemStack stack;
+            if (HopperHelper.isFireInventoryMoveItemEvent(ihopper)) {
+                // TacoSpigot end
 
-                        // CraftBukkit start - Call event when pushing items into other inventories
-                        CraftItemStack oitemstack = CraftItemStack.asCraftMirror(this.splitStack(i, world.spigotConfig.hopperAmount)); // Spigot
-                        // TacoSpigot start - add an option to turn of InventoryMoveItemEvent
-                        final org.bukkit.inventory.ItemStack stack;
-                        if (HopperHelper.isFireInventoryMoveItemEvent(this)) {
-                        // TacoSpigot end
+                Inventory sourceInventory;
+                // Have to special case large chests as they work oddly
+                if (iinventory instanceof InventoryLargeChest) {
+                    sourceInventory = new CraftInventoryDoubleChest((InventoryLargeChest) iinventory);
+                } else {
+                    sourceInventory = iinventory.getOwner().getInventory();
+                }
 
-                        Inventory destinationInventory;
-                        // Have to special case large chests as they work oddly
-                        if (iinventory instanceof InventoryLargeChest) {
-                            destinationInventory = new org.bukkit.craftbukkit.inventory.CraftInventoryDoubleChest((InventoryLargeChest) iinventory);
-                        } else {
-                            destinationInventory = iinventory.getOwner().getInventory();
-                        }
+                InventoryMoveItemEvent event = new InventoryMoveItemEvent(sourceInventory, oitemstack.clone(), ihopper.getOwner().getInventory(), false);
 
-                        InventoryMoveItemEvent event = new InventoryMoveItemEvent(this.getOwner().getInventory(), oitemstack.clone(), destinationInventory, true);
-                        this.getWorld().getServer().getPluginManager().callEvent(event);
-                        if (event.isCancelled()) {
-                            this.setItem(i, itemstack);
-                            this.d(world.spigotConfig.hopperTransfer); // Spigot
-                            return false;
-                        }
-                        // TacoSpigot start
-                        stack = event.getItem();
-                        // handle cases where the event is not fired
-                        } else {
-                            stack = oitemstack;
-                        }
-                        int origCount = stack.getAmount(); // Spigot
-                        ItemStack itemstack1 = addItem(iinventory, CraftItemStack.asNMSCopy(stack), enumdirection);
-                        // TacoSpigot end
+                ihopper.getWorld().getServer().getPluginManager().callEvent(event);
+                if (event.isCancelled()) {
+                    iinventory.setItem(i, itemstack1);
 
-                        if (itemstack1 == null || itemstack1.count == 0) {
-                            if (stack.equals(oitemstack)) { // TacoSpigot - event.getItem() -> stack
-                                iinventory.update();
-                            } else {
-                                this.setItem(i, itemstack);
-                            }
-                            // CraftBukkit end
-                            return true;
-                        }
-                        itemstack.count -= origCount - itemstack1.count; // Spigot
-                        this.setItem(i, itemstack);
+                    if (ihopper instanceof TileEntityHopper) {
+                        ((TileEntityHopper) ihopper).d(ihopper.getWorld().spigotConfig.hopperTransfer); // Spigot
+                    } else if (ihopper instanceof EntityMinecartHopper) {
+                        ((EntityMinecartHopper) ihopper).m(ihopper.getWorld().spigotConfig.hopperTransfer / 2); // Spigot
                     }
+                    return false;
                 }
+                // TacoSpigot start
+                stack = event.getItem();
+                // handle cases where the event is not fired
+            } else {
+                stack = oitemstack;
+            }
+            int origCount = stack.getAmount(); // Spigot
+            ItemStack itemstack2 = addItem(ihopper, CraftItemStack.asNMSCopy(stack), null);
+            // TacoSpigot end
 
-                return false;
+            if (itemstack2 == null || itemstack2.count == 0) {
+                if (stack.equals(oitemstack)) {
+                    iinventory.update();
+                } else {
+                    iinventory.setItem(i, itemstack1);
+                }
+                // CraftBukkit end
+                return true;
             }
+            itemstack1.count -= origCount - itemstack2.count; // Spigot
+
+            iinventory.setItem(i, itemstack1);
         }
+
+        return false;
     }
 
     private boolean a(IInventory iinventory, EnumDirection enumdirection) {
@@ -415,67 +410,6 @@ public class TileEntityHopper extends TileEntityContainer implements IHopper, IU
         return false;
     }
 
-    private static boolean a(IHopper ihopper, IInventory iinventory, int i, EnumDirection enumdirection) {
-        ItemStack itemstack = iinventory.getItem(i);
-
-        if (itemstack != null && b(iinventory, itemstack, i, enumdirection)) {
-            ItemStack itemstack1 = itemstack.cloneItemStack();
-            // ItemStack itemstack2 = addItem(ihopper, iinventory.splitStack(i, 1), (EnumDirection) null);
-            // CraftBukkit start - Call event on collection of items from inventories into the hopper
-            CraftItemStack oitemstack = CraftItemStack.asCraftMirror(iinventory.splitStack(i, ihopper.getWorld().spigotConfig.hopperAmount)); // Spigot
-            // TacoSpigot start - add an option to turn of InventoryMoveItemEvent
-            final org.bukkit.inventory.ItemStack stack;
-            if (HopperHelper.isFireInventoryMoveItemEvent(ihopper)) {
-            // TacoSpigot end
-
-            Inventory sourceInventory;
-            // Have to special case large chests as they work oddly
-            if (iinventory instanceof InventoryLargeChest) {
-                sourceInventory = new org.bukkit.craftbukkit.inventory.CraftInventoryDoubleChest((InventoryLargeChest) iinventory);
-            } else {
-                sourceInventory = iinventory.getOwner().getInventory();
-            }
-
-            InventoryMoveItemEvent event = new InventoryMoveItemEvent(sourceInventory, oitemstack.clone(), ihopper.getOwner().getInventory(), false);
-
-            ihopper.getWorld().getServer().getPluginManager().callEvent(event);
-            if (event.isCancelled()) {
-                iinventory.setItem(i, itemstack1);
-
-                if (ihopper instanceof TileEntityHopper) {
-                    ((TileEntityHopper) ihopper).d(ihopper.getWorld().spigotConfig.hopperTransfer); // Spigot
-                } else if (ihopper instanceof EntityMinecartHopper) {
-                    ((EntityMinecartHopper) ihopper).m(ihopper.getWorld().spigotConfig.hopperTransfer / 2); // Spigot
-                }
-                return false;
-            }
-            // TacoSpigot start
-            stack = event.getItem();
-            // handle cases where the event is not fired
-            } else {
-                stack = oitemstack;
-            }
-            int origCount = stack.getAmount(); // Spigot
-            ItemStack itemstack2 = addItem(ihopper, CraftItemStack.asNMSCopy(stack), null);
-            // TacoSpigot end
-
-            if (itemstack2 == null || itemstack2.count == 0) {
-                if (stack.equals(oitemstack)) {
-                    iinventory.update();
-                } else {
-                    iinventory.setItem(i, itemstack1);
-                }
-                // CraftBukkit end
-                return true;
-            }
-            itemstack1.count -= origCount - itemstack2.count; // Spigot
-
-            iinventory.setItem(i, itemstack1);
-        }
-
-        return false;
-    }
-
     public static boolean a(IInventory iinventory, EntityItem entityitem) {
         boolean flag = false;
 
@@ -483,7 +417,7 @@ public class TileEntityHopper extends TileEntityContainer implements IHopper, IU
             return false;
         } else {
             // CraftBukkit start
-            InventoryPickupItemEvent event = new InventoryPickupItemEvent(iinventory.getOwner().getInventory(), (org.bukkit.entity.Item) entityitem.getBukkitEntity());
+            InventoryPickupItemEvent event = new InventoryPickupItemEvent(iinventory.getOwner().getInventory(), (Item) entityitem.getBukkitEntity());
             entityitem.world.getServer().getPluginManager().callEvent(event);
             if (event.isCancelled()) {
                 return false;
@@ -503,6 +437,37 @@ public class TileEntityHopper extends TileEntityContainer implements IHopper, IU
         }
     }
 
+    public static IInventory b(World world, double d0, double d1, double d2) {
+        Object object = null;
+        int i = MathHelper.floor(d0);
+        int j = MathHelper.floor(d1);
+        int k = MathHelper.floor(d2);
+        BlockPosition blockposition = new BlockPosition(i, j, k);
+        if (!world.isLoaded(blockposition)) return null; // Spigot
+        Block block = world.getType(blockposition).getBlock();
+
+        if (block.isTileEntity()) {
+            TileEntity tileentity = world.getTileEntity(blockposition);
+
+            if (tileentity instanceof IInventory) {
+                object = tileentity;
+                if (object instanceof TileEntityChest && block instanceof BlockChest) {
+                    object = ((BlockChest) block).f(world, blockposition);
+                }
+            }
+        }
+
+        if (object == null) {
+            List list = world.a((Entity) null, new AxisAlignedBB(d0 - 0.5D, d1 - 0.5D, d2 - 0.5D, d0 + 0.5D, d1 + 0.5D, d2 + 0.5D), IEntitySelector.c::test);
+
+            if (list.size() > 0) {
+                object = list.get(world.random.nextInt(list.size()));
+            }
+        }
+
+        return (IInventory) object;
+    }
+
     public static ItemStack addItem(IInventory iinventory, ItemStack itemstack, EnumDirection enumdirection) {
         if (iinventory instanceof IWorldInventory && enumdirection != null) {
             IWorldInventory iworldinventory = (IWorldInventory) iinventory;
@@ -585,35 +550,73 @@ public class TileEntityHopper extends TileEntityContainer implements IHopper, IU
         return world.a(EntityItem.class, new AxisAlignedBB(d0 - 0.5D, d1 - 0.5D, d2 - 0.5D, d0 + 0.5D, d1 + 0.5D, d2 + 0.5D), IEntitySelector.a);
     }
 
-    public static IInventory b(World world, double d0, double d1, double d2) {
-        Object object = null;
-        int i = MathHelper.floor(d0);
-        int j = MathHelper.floor(d1);
-        int k = MathHelper.floor(d2);
-        BlockPosition blockposition = new BlockPosition(i, j, k);
-        if ( !world.isLoaded( blockposition ) ) return null; // Spigot
-        Block block = world.getType(blockposition).getBlock();
+    private boolean r() {
+        // TacoSpigot start - Don't use inefficient H() which does another bounding box search
+        IInventory iinventory = HopperHelper.getInventory(getWorld(), getPosition().shift(BlockHopper.b(this.u())));
+        // TacoSpigot end
 
-        if (block.isTileEntity()) {
-            TileEntity tileentity = world.getTileEntity(blockposition);
+        if (iinventory == null) {
+            return false;
+        } else {
+            EnumDirection enumdirection = BlockHopper.b(this.u()).opposite();
 
-            if (tileentity instanceof IInventory) {
-                object = tileentity;
-                if (object instanceof TileEntityChest && block instanceof BlockChest) {
-                    object = ((BlockChest) block).f(world, blockposition);
-                }
-            }
-        }
+            if (this.a(iinventory, enumdirection)) {
+                return false;
+            } else {
+                for (int i = 0; i < this.getSize(); ++i) {
+                    if (this.getItem(i) != null) {
+                        ItemStack itemstack = this.getItem(i).cloneItemStack();
+                        // ItemStack itemstack1 = addItem(iinventory, this.splitStack(i, 1), enumdirection);
 
-        if (object == null) {
-            List list = world.a((Entity) null, new AxisAlignedBB(d0 - 0.5D, d1 - 0.5D, d2 - 0.5D, d0 + 0.5D, d1 + 0.5D, d2 + 0.5D), IEntitySelector.c);
+                        // CraftBukkit start - Call event when pushing items into other inventories
+                        CraftItemStack oitemstack = CraftItemStack.asCraftMirror(this.splitStack(i, world.spigotConfig.hopperAmount)); // Spigot
+                        // TacoSpigot start - add an option to turn of InventoryMoveItemEvent
+                        final org.bukkit.inventory.ItemStack stack;
+                        if (HopperHelper.isFireInventoryMoveItemEvent(this)) {
+                            // TacoSpigot end
 
-            if (list.size() > 0) {
-                object = list.get(world.random.nextInt(list.size()));
+                            Inventory destinationInventory;
+                            // Have to special case large chests as they work oddly
+                            if (iinventory instanceof InventoryLargeChest) {
+                                destinationInventory = new CraftInventoryDoubleChest((InventoryLargeChest) iinventory);
+                            } else {
+                                destinationInventory = iinventory.getOwner().getInventory();
+                            }
+
+                            InventoryMoveItemEvent event = new InventoryMoveItemEvent(this.getOwner().getInventory(), oitemstack.clone(), destinationInventory, true);
+                            this.getWorld().getServer().getPluginManager().callEvent(event);
+                            if (event.isCancelled()) {
+                                this.setItem(i, itemstack);
+                                this.d(world.spigotConfig.hopperTransfer); // Spigot
+                                return false;
+                            }
+                            // TacoSpigot start
+                            stack = event.getItem();
+                            // handle cases where the event is not fired
+                        } else {
+                            stack = oitemstack;
+                        }
+                        int origCount = stack.getAmount(); // Spigot
+                        ItemStack itemstack1 = addItem(iinventory, CraftItemStack.asNMSCopy(stack), enumdirection);
+                        // TacoSpigot end
+
+                        if (itemstack1 == null || itemstack1.count == 0) {
+                            if (stack.equals(oitemstack)) { // TacoSpigot - event.getItem() -> stack
+                                iinventory.update();
+                            } else {
+                                this.setItem(i, itemstack);
+                            }
+                            // CraftBukkit end
+                            return true;
+                        }
+                        itemstack.count -= origCount - itemstack1.count; // Spigot
+                        this.setItem(i, itemstack);
+                    }
+                }
+
+                return false;
             }
         }
-
-        return (IInventory) object;
     }
 
     // TacoSpigot start
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 6fcae957e..93603393e 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -1,5 +1,7 @@
 package net.minecraft.server;
 
+import co.aikar.timings.TimingHistory;
+import co.aikar.timings.WorldTimingsHandler;
 import com.google.common.base.Predicate;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
@@ -7,18 +9,28 @@ import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import dev.lockedthread.LockedSpigotConfig;
 import dev.lockedthread.regions.Region;
+import gnu.trove.map.hash.TLongShortHashMap;
 import it.unimi.dsi.util.XoRoShiRo128PlusRandom;
 import net.jafama.FastMath;
+import net.techcable.tacospigot.TacoSpigotWorldConfig;
 import org.bukkit.Bukkit;
 import org.bukkit.block.BlockState;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.block.CraftBlockState;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.bukkit.entity.Projectile;
+import org.bukkit.event.Cancellable;
 import org.bukkit.event.block.BlockCanBuildEvent;
 import org.bukkit.event.block.BlockPhysicsEvent;
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
 import org.bukkit.generator.ChunkGenerator;
+import org.github.paperspigot.PaperSpigotWorldConfig;
+import org.spigotmc.ActivationRange;
+import org.spigotmc.AsyncCatcher;
+import org.spigotmc.SpigotWorldConfig;
+import org.spigotmc.TickLimiter;
 
 import java.util.*;
 import java.util.concurrent.Callable;
@@ -38,7 +50,7 @@ public abstract class World implements IBlockAccess {
     private int a = 63;
     protected boolean e;
     // Spigot start - guard entity list from removals
-    public final List<Entity> entityList = new java.util.ArrayList<Entity>() {
+    public final List<Entity> entityList = new ArrayList<Entity>() {
         @Override
         public Entity remove(int index) {
             guard();
@@ -53,7 +65,7 @@ public abstract class World implements IBlockAccess {
 
         private void guard() {
             if (guardEntityList) {
-                throw new java.util.ConcurrentModificationException();
+                throw new ConcurrentModificationException();
             }
         }
     };
@@ -124,14 +136,14 @@ public abstract class World implements IBlockAccess {
 
     // Spigot start
     private boolean guardEntityList;
-    protected final gnu.trove.map.hash.TLongShortHashMap chunkTickList;
+    public final SpigotWorldConfig spigotConfig; // Spigot
     protected float growthOdds = 100;
     protected float modifiedOdds = 100;
     private final byte chunkTickRadius;
     public static boolean haveWeSilencedAPhysicsCrash;
     public static String blockLocation;
-    private org.spigotmc.TickLimiter entityLimiter;
-    private org.spigotmc.TickLimiter tileLimiter;
+    public final PaperSpigotWorldConfig paperSpigotConfig; // PaperSpigot
+    public final WorldTimingsHandler timings; // Spigot
     private int tileTickPosition;
     public ExecutorService lightingExecutor = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder().setNameFormat("PaperSpigot - Lighting Thread").build()); // PaperSpigot - Asynchronous lighting updates
     //public final Map<Explosion.CacheKey, Float> explosionDensityCache = new HashMap<>(); // PaperSpigot - Optimize explosions
@@ -150,13 +162,10 @@ public abstract class World implements IBlockAccess {
         return (int) (((k >> 32) & 0xFFFF0000L) | ((k >> 16) & 0x0000FFFF));
     }
     // Spigot end
-
-    public final org.spigotmc.SpigotWorldConfig spigotConfig; // Spigot
-
-    public final org.github.paperspigot.PaperSpigotWorldConfig paperSpigotConfig; // PaperSpigot
-
-    public final co.aikar.timings.WorldTimingsHandler timings; // Spigot
-    public final net.techcable.tacospigot.TacoSpigotWorldConfig tacoSpigotConfig;
+    public final TacoSpigotWorldConfig tacoSpigotConfig;
+    protected final TLongShortHashMap chunkTickList;
+    private TickLimiter entityLimiter;
+    private TickLimiter tileLimiter;
 
     public CraftWorld getWorld() {
         return this.world;
@@ -171,9 +180,9 @@ public abstract class World implements IBlockAccess {
     }
 
     protected World(IDataManager idatamanager, WorldData worlddata, WorldProvider worldprovider, MethodProfiler methodprofiler, boolean flag, ChunkGenerator gen, org.bukkit.World.Environment env) {
-        this.spigotConfig = new org.spigotmc.SpigotWorldConfig(worlddata.getName()); // Spigot
-        this.paperSpigotConfig = new org.github.paperspigot.PaperSpigotWorldConfig(worlddata.getName()); // PaperSpigot
-        this.tacoSpigotConfig = new net.techcable.tacospigot.TacoSpigotWorldConfig(worlddata.getName()); // TacoSpigot
+        this.spigotConfig = new SpigotWorldConfig(worlddata.getName()); // Spigot
+        this.paperSpigotConfig = new PaperSpigotWorldConfig(worlddata.getName()); // PaperSpigot
+        this.tacoSpigotConfig = new TacoSpigotWorldConfig(worlddata.getName()); // TacoSpigot
         this.generator = gen;
         this.world = new CraftWorld((WorldServer) this, gen, env);
         this.ticksPerAnimalSpawns = this.getServer().getTicksPerAnimalSpawns(); // CraftBukkit
@@ -181,7 +190,7 @@ public abstract class World implements IBlockAccess {
         // CraftBukkit end
         // Spigot start
         this.chunkTickRadius = (byte) ((this.getServer().getViewDistance() < 7) ? this.getServer().getViewDistance() : 7);
-        this.chunkTickList = new gnu.trove.map.hash.TLongShortHashMap(spigotConfig.chunksPerTick * 5, 0.7f, Long.MIN_VALUE, Short.MIN_VALUE);
+        this.chunkTickList = new TLongShortHashMap(spigotConfig.chunksPerTick * 5, 0.7f, Long.MIN_VALUE, Short.MIN_VALUE);
         this.chunkTickList.setAutoCompactionFactor(0);
         // Spigot end
 
@@ -227,9 +236,9 @@ public abstract class World implements IBlockAccess {
         this.getServer().addWorld(this.world);
         // CraftBukkit end
         this.keepSpawnInMemory = this.paperSpigotConfig.keepSpawnInMemory; // PaperSpigot
-        timings = new co.aikar.timings.WorldTimingsHandler(this); // Spigot - code below can generate new world and access timings
-        this.entityLimiter = new org.spigotmc.TickLimiter(spigotConfig.entityMaxTickTime);
-        this.tileLimiter = new org.spigotmc.TickLimiter(spigotConfig.tileMaxTickTime);
+        timings = new WorldTimingsHandler(this); // Spigot - code below can generate new world and access timings
+        this.entityLimiter = new TickLimiter(spigotConfig.entityMaxTickTime);
+        this.tileLimiter = new TickLimiter(spigotConfig.tileMaxTickTime);
     }
 
     public World b() {
@@ -360,7 +369,7 @@ public abstract class World implements IBlockAccess {
                 }
             }
             if (blockstate == null) {
-                blockstate = org.bukkit.craftbukkit.block.CraftBlockState.getBlockState(this, blockposition.getX(), blockposition.getY(), blockposition.getZ(), i);
+                blockstate = CraftBlockState.getBlockState(this, blockposition.getX(), blockposition.getY(), blockposition.getZ(), i);
             }
             blockstate.setTypeId(CraftMagicNumbers.getId(iblockdata.getBlock()));
             blockstate.setRawData((byte) iblockdata.getBlock().toLegacyData(iblockdata));
@@ -379,7 +388,7 @@ public abstract class World implements IBlockAccess {
             // CraftBukkit start - capture blockstates
             BlockState blockstate = null;
             if (this.captureBlockStates) {
-                blockstate = org.bukkit.craftbukkit.block.CraftBlockState.getBlockState(this, blockposition.getX(), blockposition.getY(), blockposition.getZ(), i);
+                blockstate = CraftBlockState.getBlockState(this, blockposition.getX(), blockposition.getY(), blockposition.getZ(), i);
                 this.capturedBlockStates.add(blockstate);
             }
             // CraftBukkit end
@@ -982,7 +991,7 @@ public abstract class World implements IBlockAccess {
     }
 
     public boolean addEntity(Entity entity, SpawnReason spawnReason) { // Changed signature, added SpawnReason
-        org.spigotmc.AsyncCatcher.catchOp("entity add"); // Spigot
+        AsyncCatcher.catchOp("entity add"); // Spigot
         if (entity == null) return false;
         // CraftBukkit end
         int i = MathHelper.floor(entity.locX / 16.0D);
@@ -994,7 +1003,7 @@ public abstract class World implements IBlockAccess {
         }
 
         // CraftBukkit start
-        org.bukkit.event.Cancellable event = null;
+        Cancellable event = null;
         if (entity instanceof EntityLiving && !(entity instanceof EntityPlayer)) {
             boolean isAnimal = entity instanceof EntityAnimal || entity instanceof EntityWaterAnimal || entity instanceof EntityGolem;
             boolean isMonster = entity instanceof EntityMonster || entity instanceof EntityGhast || entity instanceof EntitySlime;
@@ -1009,7 +1018,7 @@ public abstract class World implements IBlockAccess {
             event = CraftEventFactory.callCreatureSpawnEvent((EntityLiving) entity, spawnReason);
         } else if (entity instanceof EntityItem) {
             event = CraftEventFactory.callItemSpawnEvent((EntityItem) entity);
-        } else if (entity.getBukkitEntity() instanceof org.bukkit.entity.Projectile) {
+        } else if (entity.getBukkitEntity() instanceof Projectile) {
             // Not all projectiles extend EntityProjectile, so check for Bukkit interface instead
             event = CraftEventFactory.callProjectileLaunchEvent(entity);
         }
@@ -1099,7 +1108,7 @@ public abstract class World implements IBlockAccess {
     }
 
     public void removeEntity(Entity entity) {
-        org.spigotmc.AsyncCatcher.catchOp("entity remove"); // Spigot
+        AsyncCatcher.catchOp("entity remove"); // Spigot
         entity.die();
         if (entity instanceof EntityHuman) {
             this.players.remove(entity);
@@ -1407,11 +1416,11 @@ public abstract class World implements IBlockAccess {
         timings.entityRemoval.stopTiming(); // Spigot
         this.methodProfiler.c("regular");
 
-        org.spigotmc.ActivationRange.activateEntities(this); // Spigot
+        ActivationRange.activateEntities(this); // Spigot
         timings.entityTick.startTiming(); // Spigot
         guardEntityList = true; // Spigot
         // CraftBukkit start - Use field for loop variable
-        co.aikar.timings.TimingHistory.entityTicks += this.entityList.size(); // Spigot
+        TimingHistory.entityTicks += this.entityList.size(); // Spigot
         // PaperSpigot start - Disable tick limiters
         //if (tickPosition < 0) tickPosition = 0;
         for (tickPosition = 0; tickPosition < entityList.size(); tickPosition++) {
@@ -1554,7 +1563,7 @@ public abstract class World implements IBlockAccess {
         }
 
         timings.tileEntityPending.stopTiming(); // Spigot
-        co.aikar.timings.TimingHistory.tileEntityTicks += this.tileEntityList.size(); // Spigot
+        TimingHistory.tileEntityTicks += this.tileEntityList.size(); // Spigot
 
         this.methodProfiler.b();
         this.methodProfiler.b();
@@ -1592,7 +1601,7 @@ public abstract class World implements IBlockAccess {
         int j = MathHelper.floor(entity.locZ);
 
         // Spigot start
-        if (!org.spigotmc.ActivationRange.checkIfActive(entity)) {
+        if (!ActivationRange.checkIfActive(entity)) {
             entity.ticksLived++;
             entity.inactiveTick();
             // PaperSpigot start - Remove entities in unloaded chunks
@@ -1612,7 +1621,7 @@ public abstract class World implements IBlockAccess {
             entity.lastPitch = entity.pitch;
             if (flag && entity.ad) {
                 ++entity.ticksLived;
-                ++co.aikar.timings.TimingHistory.activatedEntityTicks; // Spigot
+                ++TimingHistory.activatedEntityTicks; // Spigot
                 if (entity.vehicle != null) {
                     entity.ak();
                 } else {
@@ -2564,10 +2573,10 @@ public abstract class World implements IBlockAccess {
     }
 
     public List<Entity> getEntities(Entity entity, AxisAlignedBB axisalignedbb) {
-        return this.a(entity, axisalignedbb, IEntitySelector.d);
+        return this.a(entity, axisalignedbb, (java.util.function.Predicate<Entity>) IEntitySelector.d);
     }
 
-    public List<Entity> a(Entity entity, AxisAlignedBB axisalignedbb, Predicate<? super Entity> predicate) {
+    public List<Entity> a(Entity entity, AxisAlignedBB axisalignedbb, java.util.function.Predicate<Entity> predicate) {
         ArrayList<Entity> arraylist = Lists.newArrayList();
         int i = MathHelper.floor((axisalignedbb.a - 2.0D) / 16.0D);
         int j = MathHelper.floor((axisalignedbb.d + 2.0D) / 16.0D);
@@ -2686,7 +2695,7 @@ public abstract class World implements IBlockAccess {
     }
 
     public void b(Collection<Entity> collection) {
-        org.spigotmc.AsyncCatcher.catchOp("entity world add"); // Spigot
+        AsyncCatcher.catchOp("entity world add"); // Spigot
         // CraftBukkit start
         // this.entityList.addAll(collection);
 
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index 998683f06..690babfc4 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -1,30 +1,27 @@
 package org.bukkit.craftbukkit.entity;
 
 import com.google.common.base.Preconditions;
-
-import java.util.List;
-import java.util.Set;
-import java.util.UUID;
-
 import net.minecraft.server.*;
-
 import org.bukkit.EntityEffect;
 import org.bukkit.Location;
 import org.bukkit.Server;
 import org.bukkit.World;
 import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.entity.EntityType;
 import org.bukkit.event.entity.EntityDamageEvent;
 import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
 import org.bukkit.metadata.MetadataValue;
-import org.bukkit.permissions.PermissibleBase;
-import org.bukkit.permissions.Permission;
-import org.bukkit.permissions.PermissionAttachment;
-import org.bukkit.permissions.PermissionAttachmentInfo;
-import org.bukkit.permissions.ServerOperator;
+import org.bukkit.permissions.*;
 import org.bukkit.plugin.Plugin;
 import org.bukkit.util.Vector;
 import org.github.paperspigot.PaperSpigotConfig;
 
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import java.util.UUID;
+import java.util.function.Predicate;
+
 public abstract class CraftEntity implements org.bukkit.entity.Entity {
     private static final PermissibleBase perm = new PermissibleBase(new ServerOperator() {
 
@@ -38,7 +35,7 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
 
         }
     });
-    
+
     protected final CraftServer server;
     protected Entity entity;
     private EntityDamageEvent lastDamageEvent;
@@ -48,6 +45,31 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         this.entity = entity;
     }
 
+    // Spigot start
+    private final Spigot spigot = new Spigot() {
+        @Override
+        public boolean isInvulnerable() {
+            return getHandle().isInvulnerable(DamageSource.GENERIC);
+        }
+    };
+
+    public Location getLocation() {
+        return new Location(getWorld(), entity.locX, entity.locY, entity.locZ, entity.yaw, entity.pitch);
+    }
+
+    public Location getLocation(Location loc) {
+        if (loc != null) {
+            loc.setWorld(getWorld());
+            loc.setX(entity.locX);
+            loc.setY(entity.locY);
+            loc.setZ(entity.locZ);
+            loc.setYaw(entity.yaw);
+            loc.setPitch(entity.pitch);
+        }
+
+        return loc;
+    }
+
     public static CraftEntity getEntity(CraftServer server, Entity entity) {
         /**
          * Order is *EXTREMELY* important -- keep it right! =D
@@ -55,159 +77,245 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         if (entity instanceof EntityLiving) {
             // Players
             if (entity instanceof EntityHuman) {
-                if (entity instanceof EntityPlayer) { return new CraftPlayer(server, (EntityPlayer) entity); }
-                else { return new CraftHumanEntity(server, (EntityHuman) entity); }
+                if (entity instanceof EntityPlayer) {
+                    return new CraftPlayer(server, (EntityPlayer) entity);
+                } else {
+                    return new CraftHumanEntity(server, (EntityHuman) entity);
+                }
             }
             // Water Animals
             else if (entity instanceof EntityWaterAnimal) {
-                if (entity instanceof EntitySquid) { return new CraftSquid(server, (EntitySquid) entity); }
-                else { return new CraftWaterMob(server, (EntityWaterAnimal) entity); }
-            }
-            else if (entity instanceof EntityCreature) {
+                if (entity instanceof EntitySquid) {
+                    return new CraftSquid(server, (EntitySquid) entity);
+                } else {
+                    return new CraftWaterMob(server, (EntityWaterAnimal) entity);
+                }
+            } else if (entity instanceof EntityCreature) {
                 // Animals
                 if (entity instanceof EntityAnimal) {
-                    if (entity instanceof EntityChicken) { return new CraftChicken(server, (EntityChicken) entity); }
-                    else if (entity instanceof EntityCow) {
-                        if (entity instanceof EntityMushroomCow) { return new CraftMushroomCow(server, (EntityMushroomCow) entity); }
-                        else { return new CraftCow(server, (EntityCow) entity); }
+                    if (entity instanceof EntityChicken) {
+                        return new CraftChicken(server, (EntityChicken) entity);
+                    } else if (entity instanceof EntityCow) {
+                        if (entity instanceof EntityMushroomCow) {
+                            return new CraftMushroomCow(server, (EntityMushroomCow) entity);
+                        } else {
+                            return new CraftCow(server, (EntityCow) entity);
+                        }
+                    } else if (entity instanceof EntityPig) {
+                        return new CraftPig(server, (EntityPig) entity);
+                    } else if (entity instanceof EntityTameableAnimal) {
+                        if (entity instanceof EntityWolf) {
+                            return new CraftWolf(server, (EntityWolf) entity);
+                        } else if (entity instanceof EntityOcelot) {
+                            return new CraftOcelot(server, (EntityOcelot) entity);
+                        }
+                    } else if (entity instanceof EntitySheep) {
+                        return new CraftSheep(server, (EntitySheep) entity);
+                    } else if (entity instanceof EntityHorse) {
+                        return new CraftHorse(server, (EntityHorse) entity);
+                    } else if (entity instanceof EntityRabbit) {
+                        return new CraftRabbit(server, (EntityRabbit) entity);
+                    } else {
+                        return new CraftAnimals(server, (EntityAnimal) entity);
                     }
-                    else if (entity instanceof EntityPig) { return new CraftPig(server, (EntityPig) entity); }
-                    else if (entity instanceof EntityTameableAnimal) {
-                        if (entity instanceof EntityWolf) { return new CraftWolf(server, (EntityWolf) entity); }
-                        else if (entity instanceof EntityOcelot) { return new CraftOcelot(server, (EntityOcelot) entity); }
-                    }
-                    else if (entity instanceof EntitySheep) { return new CraftSheep(server, (EntitySheep) entity); }
-                    else if (entity instanceof EntityHorse) { return new CraftHorse(server, (EntityHorse) entity); }
-                    else if (entity instanceof EntityRabbit) { return new CraftRabbit(server, (EntityRabbit) entity); }
-                    else  { return new CraftAnimals(server, (EntityAnimal) entity); }
                 }
                 // Monsters
                 else if (entity instanceof EntityMonster) {
                     if (entity instanceof EntityZombie) {
-                        if (entity instanceof EntityPigZombie) { return new CraftPigZombie(server, (EntityPigZombie) entity); }
-                        else { return new CraftZombie(server, (EntityZombie) entity); }
+                        if (entity instanceof EntityPigZombie) {
+                            return new CraftPigZombie(server, (EntityPigZombie) entity);
+                        } else {
+                            return new CraftZombie(server, (EntityZombie) entity);
+                        }
+                    } else if (entity instanceof EntityCreeper) {
+                        return new CraftCreeper(server, (EntityCreeper) entity);
+                    } else if (entity instanceof EntityEnderman) {
+                        return new CraftEnderman(server, (EntityEnderman) entity);
+                    } else if (entity instanceof EntitySilverfish) {
+                        return new CraftSilverfish(server, (EntitySilverfish) entity);
+                    } else if (entity instanceof EntityGiantZombie) {
+                        return new CraftGiant(server, (EntityGiantZombie) entity);
+                    } else if (entity instanceof EntitySkeleton) {
+                        return new CraftSkeleton(server, (EntitySkeleton) entity);
+                    } else if (entity instanceof EntityBlaze) {
+                        return new CraftBlaze(server, (EntityBlaze) entity);
+                    } else if (entity instanceof EntityWitch) {
+                        return new CraftWitch(server, (EntityWitch) entity);
+                    } else if (entity instanceof EntityWither) {
+                        return new CraftWither(server, (EntityWither) entity);
+                    } else if (entity instanceof EntitySpider) {
+                        if (entity instanceof EntityCaveSpider) {
+                            return new CraftCaveSpider(server, (EntityCaveSpider) entity);
+                        } else {
+                            return new CraftSpider(server, (EntitySpider) entity);
+                        }
+                    } else if (entity instanceof EntityEndermite) {
+                        return new CraftEndermite(server, (EntityEndermite) entity);
+                    } else if (entity instanceof EntityGuardian) {
+                        return new CraftGuardian(server, (EntityGuardian) entity);
+                    } else {
+                        return new CraftMonster(server, (EntityMonster) entity);
                     }
-                    else if (entity instanceof EntityCreeper) { return new CraftCreeper(server, (EntityCreeper) entity); }
-                    else if (entity instanceof EntityEnderman) { return new CraftEnderman(server, (EntityEnderman) entity); }
-                    else if (entity instanceof EntitySilverfish) { return new CraftSilverfish(server, (EntitySilverfish) entity); }
-                    else if (entity instanceof EntityGiantZombie) { return new CraftGiant(server, (EntityGiantZombie) entity); }
-                    else if (entity instanceof EntitySkeleton) { return new CraftSkeleton(server, (EntitySkeleton) entity); }
-                    else if (entity instanceof EntityBlaze) { return new CraftBlaze(server, (EntityBlaze) entity); }
-                    else if (entity instanceof EntityWitch) { return new CraftWitch(server, (EntityWitch) entity); }
-                    else if (entity instanceof EntityWither) { return new CraftWither(server, (EntityWither) entity); }
-                    else if (entity instanceof EntitySpider) {
-                        if (entity instanceof EntityCaveSpider) { return new CraftCaveSpider(server, (EntityCaveSpider) entity); }
-                        else { return new CraftSpider(server, (EntitySpider) entity); }
+                } else if (entity instanceof EntityGolem) {
+                    if (entity instanceof EntitySnowman) {
+                        return new CraftSnowman(server, (EntitySnowman) entity);
+                    } else if (entity instanceof EntityIronGolem) {
+                        return new CraftIronGolem(server, (EntityIronGolem) entity);
                     }
-                    else if (entity instanceof EntityEndermite) { return new CraftEndermite(server, (EntityEndermite) entity); }
-                    else if (entity instanceof EntityGuardian) { return new CraftGuardian(server, (EntityGuardian) entity); }
-
-                    else  { return new CraftMonster(server, (EntityMonster) entity); }
+                } else if (entity instanceof EntityVillager) {
+                    return new CraftVillager(server, (EntityVillager) entity);
+                } else {
+                    return new CraftCreature(server, (EntityCreature) entity);
                 }
-                else if (entity instanceof EntityGolem) {
-                    if (entity instanceof EntitySnowman) { return new CraftSnowman(server, (EntitySnowman) entity); }
-                    else if (entity instanceof EntityIronGolem) { return new CraftIronGolem(server, (EntityIronGolem) entity); }
-                }
-                else if (entity instanceof EntityVillager) { return new CraftVillager(server, (EntityVillager) entity); }
-                else { return new CraftCreature(server, (EntityCreature) entity); }
             }
             // Slimes are a special (and broken) case
             else if (entity instanceof EntitySlime) {
-                if (entity instanceof EntityMagmaCube) { return new CraftMagmaCube(server, (EntityMagmaCube) entity); }
-                else { return new CraftSlime(server, (EntitySlime) entity); }
+                if (entity instanceof EntityMagmaCube) {
+                    return new CraftMagmaCube(server, (EntityMagmaCube) entity);
+                } else {
+                    return new CraftSlime(server, (EntitySlime) entity);
+                }
             }
             // Flying
             else if (entity instanceof EntityFlying) {
-                if (entity instanceof EntityGhast) { return new CraftGhast(server, (EntityGhast) entity); }
-                else { return new CraftFlying(server, (EntityFlying) entity); }
-            }
-            else if (entity instanceof EntityEnderDragon) {
+                if (entity instanceof EntityGhast) {
+                    return new CraftGhast(server, (EntityGhast) entity);
+                } else {
+                    return new CraftFlying(server, (EntityFlying) entity);
+                }
+            } else if (entity instanceof EntityEnderDragon) {
                 return new CraftEnderDragon(server, (EntityEnderDragon) entity);
             }
             // Ambient
             else if (entity instanceof EntityAmbient) {
-                if (entity instanceof EntityBat) { return new CraftBat(server, (EntityBat) entity); }
-                else { return new CraftAmbient(server, (EntityAmbient) entity); }
+                if (entity instanceof EntityBat) {
+                    return new CraftBat(server, (EntityBat) entity);
+                } else {
+                    return new CraftAmbient(server, (EntityAmbient) entity);
+                }
+            } else if (entity instanceof EntityArmorStand) {
+                return new CraftArmorStand(server, (EntityArmorStand) entity);
+            } else {
+                return new CraftLivingEntity(server, (EntityLiving) entity);
             }
-            else if (entity instanceof EntityArmorStand) { return new CraftArmorStand(server, (EntityArmorStand) entity); }
-            else  { return new CraftLivingEntity(server, (EntityLiving) entity); }
-        }
-        else if (entity instanceof EntityComplexPart) {
+        } else if (entity instanceof EntityComplexPart) {
             EntityComplexPart part = (EntityComplexPart) entity;
-            if (part.owner instanceof EntityEnderDragon) { return new CraftEnderDragonPart(server, (EntityComplexPart) entity); }
-            else { return new CraftComplexPart(server, (EntityComplexPart) entity); }
-        }
-        else if (entity instanceof EntityExperienceOrb) { return new CraftExperienceOrb(server, (EntityExperienceOrb) entity); }
-        else if (entity instanceof EntityArrow) { return new CraftArrow(server, (EntityArrow) entity); }
-        else if (entity instanceof EntityBoat) { return new CraftBoat(server, (EntityBoat) entity); }
-        else if (entity instanceof EntityProjectile) {
-            if (entity instanceof EntityEgg) { return new CraftEgg(server, (EntityEgg) entity); }
-            else if (entity instanceof EntitySnowball) { return new CraftSnowball(server, (EntitySnowball) entity); }
-            else if (entity instanceof EntityPotion) { return new CraftThrownPotion(server, (EntityPotion) entity); }
-            else if (entity instanceof EntityEnderPearl) { return new CraftEnderPearl(server, (EntityEnderPearl) entity); }
-            else if (entity instanceof EntityThrownExpBottle) { return new CraftThrownExpBottle(server, (EntityThrownExpBottle) entity); }
-        }
-        else if (entity instanceof EntityFallingBlock) { return new CraftFallingSand(server, (EntityFallingBlock) entity); }
-        else if (entity instanceof EntityFireball) {
-            if (entity instanceof EntitySmallFireball) { return new CraftSmallFireball(server, (EntitySmallFireball) entity); }
-            else if (entity instanceof EntityLargeFireball) { return new CraftLargeFireball(server, (EntityLargeFireball) entity); }
-            else if (entity instanceof EntityWitherSkull) { return new CraftWitherSkull(server, (EntityWitherSkull) entity); }
-            else { return new CraftFireball(server, (EntityFireball) entity); }
-        }
-        else if (entity instanceof EntityEnderSignal) { return new CraftEnderSignal(server, (EntityEnderSignal) entity); }
-        else if (entity instanceof EntityEnderCrystal) { return new CraftEnderCrystal(server, (EntityEnderCrystal) entity); }
-        else if (entity instanceof EntityFishingHook) { return new CraftFish(server, (EntityFishingHook) entity); }
-        else if (entity instanceof EntityItem) { return new CraftItem(server, (EntityItem) entity); }
-        else if (entity instanceof EntityWeather) {
-            if (entity instanceof EntityLightning) { return new CraftLightningStrike(server, (EntityLightning) entity); }
-            else { return new CraftWeather(server, (EntityWeather) entity); }
-        }
-        else if (entity instanceof EntityMinecartAbstract) {
-            if (entity instanceof EntityMinecartFurnace) { return new CraftMinecartFurnace(server, (EntityMinecartFurnace) entity); }
-            else if (entity instanceof EntityMinecartChest) { return new CraftMinecartChest(server, (EntityMinecartChest) entity); }
-            else if (entity instanceof EntityMinecartTNT) { return new CraftMinecartTNT(server, (EntityMinecartTNT) entity); }
-            else if (entity instanceof EntityMinecartHopper) { return new CraftMinecartHopper(server, (EntityMinecartHopper) entity); }
-            else if (entity instanceof EntityMinecartMobSpawner) { return new CraftMinecartMobSpawner(server, (EntityMinecartMobSpawner) entity); }
-            else if (entity instanceof EntityMinecartRideable) { return new CraftMinecartRideable(server, (EntityMinecartRideable) entity); }
-            else if (entity instanceof EntityMinecartCommandBlock) { return new CraftMinecartCommand(server, (EntityMinecartCommandBlock) entity); }
+            if (part.owner instanceof EntityEnderDragon) {
+                return new CraftEnderDragonPart(server, (EntityComplexPart) entity);
+            } else {
+                return new CraftComplexPart(server, (EntityComplexPart) entity);
+            }
+        } else if (entity instanceof EntityExperienceOrb) {
+            return new CraftExperienceOrb(server, (EntityExperienceOrb) entity);
+        } else if (entity instanceof EntityArrow) {
+            return new CraftArrow(server, (EntityArrow) entity);
+        } else if (entity instanceof EntityBoat) {
+            return new CraftBoat(server, (EntityBoat) entity);
+        } else if (entity instanceof EntityProjectile) {
+            if (entity instanceof EntityEgg) {
+                return new CraftEgg(server, (EntityEgg) entity);
+            } else if (entity instanceof EntitySnowball) {
+                return new CraftSnowball(server, (EntitySnowball) entity);
+            } else if (entity instanceof EntityPotion) {
+                return new CraftThrownPotion(server, (EntityPotion) entity);
+            } else if (entity instanceof EntityEnderPearl) {
+                return new CraftEnderPearl(server, (EntityEnderPearl) entity);
+            } else if (entity instanceof EntityThrownExpBottle) {
+                return new CraftThrownExpBottle(server, (EntityThrownExpBottle) entity);
+            }
+        } else if (entity instanceof EntityFallingBlock) {
+            return new CraftFallingSand(server, (EntityFallingBlock) entity);
+        } else if (entity instanceof EntityFireball) {
+            if (entity instanceof EntitySmallFireball) {
+                return new CraftSmallFireball(server, (EntitySmallFireball) entity);
+            } else if (entity instanceof EntityLargeFireball) {
+                return new CraftLargeFireball(server, (EntityLargeFireball) entity);
+            } else if (entity instanceof EntityWitherSkull) {
+                return new CraftWitherSkull(server, (EntityWitherSkull) entity);
+            } else {
+                return new CraftFireball(server, (EntityFireball) entity);
+            }
+        } else if (entity instanceof EntityEnderSignal) {
+            return new CraftEnderSignal(server, (EntityEnderSignal) entity);
+        } else if (entity instanceof EntityEnderCrystal) {
+            return new CraftEnderCrystal(server, (EntityEnderCrystal) entity);
+        } else if (entity instanceof EntityFishingHook) {
+            return new CraftFish(server, (EntityFishingHook) entity);
+        } else if (entity instanceof EntityItem) {
+            return new CraftItem(server, (EntityItem) entity);
+        } else if (entity instanceof EntityWeather) {
+            if (entity instanceof EntityLightning) {
+                return new CraftLightningStrike(server, (EntityLightning) entity);
+            } else {
+                return new CraftWeather(server, (EntityWeather) entity);
+            }
+        } else if (entity instanceof EntityMinecartAbstract) {
+            if (entity instanceof EntityMinecartFurnace) {
+                return new CraftMinecartFurnace(server, (EntityMinecartFurnace) entity);
+            } else if (entity instanceof EntityMinecartChest) {
+                return new CraftMinecartChest(server, (EntityMinecartChest) entity);
+            } else if (entity instanceof EntityMinecartTNT) {
+                return new CraftMinecartTNT(server, (EntityMinecartTNT) entity);
+            } else if (entity instanceof EntityMinecartHopper) {
+                return new CraftMinecartHopper(server, (EntityMinecartHopper) entity);
+            } else if (entity instanceof EntityMinecartMobSpawner) {
+                return new CraftMinecartMobSpawner(server, (EntityMinecartMobSpawner) entity);
+            } else if (entity instanceof EntityMinecartRideable) {
+                return new CraftMinecartRideable(server, (EntityMinecartRideable) entity);
+            } else if (entity instanceof EntityMinecartCommandBlock) {
+                return new CraftMinecartCommand(server, (EntityMinecartCommandBlock) entity);
+            }
         } else if (entity instanceof EntityHanging) {
-            if (entity instanceof EntityPainting) { return new CraftPainting(server, (EntityPainting) entity); }
-            else if (entity instanceof EntityItemFrame) { return new CraftItemFrame(server, (EntityItemFrame) entity); }
-            else if (entity instanceof EntityLeash) { return new CraftLeash(server, (EntityLeash) entity); }
-            else { return new CraftHanging(server, (EntityHanging) entity); }
+            if (entity instanceof EntityPainting) {
+                return new CraftPainting(server, (EntityPainting) entity);
+            } else if (entity instanceof EntityItemFrame) {
+                return new CraftItemFrame(server, (EntityItemFrame) entity);
+            } else if (entity instanceof EntityLeash) {
+                return new CraftLeash(server, (EntityLeash) entity);
+            } else {
+                return new CraftHanging(server, (EntityHanging) entity);
+            }
+        } else if (entity instanceof EntityTNTPrimed) {
+            return new CraftTNTPrimed(server, (EntityTNTPrimed) entity);
+        } else if (entity instanceof EntityFireworks) {
+            return new CraftFirework(server, (EntityFireworks) entity);
         }
-        else if (entity instanceof EntityTNTPrimed) { return new CraftTNTPrimed(server, (EntityTNTPrimed) entity); }
-        else if (entity instanceof EntityFireworks) { return new CraftFirework(server, (EntityFireworks) entity); }
 
         throw new AssertionError("Unknown entity " + (entity == null ? null : entity.getClass()));
     }
 
-    public Location getLocation() {
-        return new Location(getWorld(), entity.locX, entity.locY, entity.locZ, entity.yaw, entity.pitch);
+    public Predicate<Entity> isTNT() {
+        return e -> e.getBukkitEntity().getType().equals(EntityType.PRIMED_TNT) && e.getBukkitEntity().getTicksLived() + 1 == this.entity.getBukkitEntity().getTicksLived() && e.getBukkitEntity().getLocation().equals(this.entity.getBukkitEntity().getLocation());
     }
 
-    public Location getLocation(Location loc) {
-        if (loc != null) {
-            loc.setWorld(getWorld());
-            loc.setX(entity.locX);
-            loc.setY(entity.locY);
-            loc.setZ(entity.locZ);
-            loc.setYaw(entity.yaw);
-            loc.setPitch(entity.pitch);
+    public Vector getVelocity() {
+        return new Vector(entity.motX, entity.motY, entity.motZ);
+    }
+
+    public List<Entity> getLocalTNTEntities() {
+        return this.entity.world.a(this.entity, this.entity.getBoundingBox().shrink(this.entity.width - 1.0E-16, this.entity.length - 1.0E-16, this.entity.width - 1.0E-16), this.isTNT());
+    }
+
+    public boolean isOnGround() {
+        if (entity instanceof EntityArrow) {
+            return ((EntityArrow) entity).isInGround();
         }
+        return entity.onGround;
+    }
 
-        return loc;
+    public World getWorld() {
+        return entity.world.getWorld();
     }
 
-    public Vector getVelocity() {
-        return new Vector(entity.motX, entity.motY, entity.motZ);
+    public boolean teleport(Location location) {
+        return teleport(location, TeleportCause.PLUGIN);
     }
 
     public void setVelocity(Vector vel) {
         // Paper start - warn server owners when plugins try to set super high velocities
         if (PaperSpigotConfig.warnForExcessiveVelocity) {
-            if(vel.getX() > 4 || vel.getX() < -4 || vel.getY() > 4 || vel.getY() < -4 || vel.getZ() > 4 || vel.getZ() < -4) {
-                getServer().getLogger().warning("Excessive velocity set detected: tried to set velocity of entity #"+getEntityId()+" to ("+vel.getX()+","+vel.getY()+","+vel.getZ()+").");
+            if (vel.getX() > 4 || vel.getX() < -4 || vel.getY() > 4 || vel.getY() < -4 || vel.getZ() > 4 || vel.getZ() < -4) {
+                getServer().getLogger().warning("Excessive velocity set detected: tried to set velocity of entity #" + getEntityId() + " to (" + vel.getX() + "," + vel.getY() + "," + vel.getZ() + ").");
                 Thread.dumpStack();
             }
         }
@@ -219,19 +327,12 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         entity.velocityChanged = true;
     }
 
-    public boolean isOnGround() {
-        if (entity instanceof EntityArrow) {
-            return ((EntityArrow) entity).isInGround();
-        }
-        return entity.onGround;
-    }
-
-    public World getWorld() {
-        return entity.world.getWorld();
+    public boolean teleport(org.bukkit.entity.Entity destination) {
+        return teleport(destination.getLocation());
     }
 
-    public boolean teleport(Location location) {
-        return teleport(location, TeleportCause.PLUGIN);
+    public boolean teleport(org.bukkit.entity.Entity destination, TeleportCause cause) {
+        return teleport(destination.getLocation(), cause);
     }
 
     public boolean teleport(Location location, TeleportCause cause) {
@@ -244,8 +345,8 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
 
         // Spigot start
         if (!location.getWorld().equals(getWorld())) {
-          entity.teleportTo(location, cause.equals(TeleportCause.NETHER_PORTAL));
-          return true;
+            entity.teleportTo(location, cause.equals(TeleportCause.NETHER_PORTAL));
+            return true;
         }
 
         // entity.world = ((CraftWorld) location.getWorld()).getHandle();
@@ -256,24 +357,6 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         return true;
     }
 
-    public boolean teleport(org.bukkit.entity.Entity destination) {
-        return teleport(destination.getLocation());
-    }
-
-    public boolean teleport(org.bukkit.entity.Entity destination, TeleportCause cause) {
-        return teleport(destination.getLocation(), cause);
-    }
-
-    public List<org.bukkit.entity.Entity> getNearbyEntities(double x, double y, double z) {
-        List<Entity> notchEntityList = entity.world.a(entity, entity.getBoundingBox().grow(x, y, z), null);
-        List<org.bukkit.entity.Entity> bukkitEntityList = new java.util.ArrayList<>(notchEntityList.size());
-
-        for (Entity e : notchEntityList) {
-            bukkitEntityList.add(e.getBukkitEntity());
-        }
-        return bukkitEntityList;
-    }
-
     public int getEntityId() {
         return entity.getId();
     }
@@ -555,18 +638,17 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         perm.setOp(value);
     }
 
-    // Spigot start
-    private final Spigot spigot = new Spigot()
-    {
-        @Override
-        public boolean isInvulnerable()
-        {
-            return getHandle().isInvulnerable(net.minecraft.server.DamageSource.GENERIC);
+    public List<org.bukkit.entity.Entity> getNearbyEntities(double x, double y, double z) {
+        List<Entity> notchEntityList = entity.world.a(entity, entity.getBoundingBox().grow(x, y, z), null);
+        List<org.bukkit.entity.Entity> bukkitEntityList = new ArrayList<>(notchEntityList.size());
+
+        for (Entity e : notchEntityList) {
+            bukkitEntityList.add(e.getBukkitEntity());
         }
-    };
+        return bukkitEntityList;
+    }
 
-    public Spigot spigot()
-    {
+    public Spigot spigot() {
         return spigot;
     }
     // Spigot end
-- 
2.21.0.windows.1

