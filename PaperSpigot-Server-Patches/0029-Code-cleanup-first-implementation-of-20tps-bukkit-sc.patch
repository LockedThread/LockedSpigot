From 4c667e109ebfefacd3bc351e790781602e915e73 Mon Sep 17 00:00:00 2001
From: Admin <lockedthreaddev@gmail.com>
Date: Sat, 4 May 2019 11:35:31 -0400
Subject: [PATCH] Code cleanup & first implementation of 20tps bukkit scheduler
 and entity tick with 40tps everything else.


diff --git a/src/main/java/net/minecraft/server/DedicatedServer.java b/src/main/java/net/minecraft/server/DedicatedServer.java
index 088beb22b..1b93a28de 100644
--- a/src/main/java/net/minecraft/server/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/DedicatedServer.java
@@ -1,35 +1,34 @@
 package net.minecraft.server;
 
+import co.aikar.timings.SpigotTimings;
 import com.google.common.collect.Lists;
-import java.io.BufferedReader;
+import org.apache.logging.log4j.Level;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.craftbukkit.LoggerOutputStream;
+import org.bukkit.craftbukkit.util.Waitable;
+import org.bukkit.event.server.RemoteServerCommandEvent;
+import org.bukkit.event.server.ServerCommandEvent;
+
 import java.io.File;
 import java.io.IOException;
-import java.io.InputStreamReader;
+import java.io.PrintStream;
 import java.net.InetAddress;
 import java.net.Proxy;
 import java.util.Collections;
 import java.util.List;
 import java.util.Random;
-import java.util.concurrent.Callable;
 import java.util.concurrent.TimeUnit;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
 
 // CraftBukkit start
-import java.io.PrintStream;
-import org.apache.logging.log4j.Level;
 
-import org.bukkit.craftbukkit.LoggerOutputStream;
-import co.aikar.timings.SpigotTimings; // Spigot
-import org.bukkit.event.server.ServerCommandEvent;
-import org.bukkit.craftbukkit.util.Waitable;
-import org.bukkit.event.server.RemoteServerCommandEvent;
+// CraftBukkit start
 // CraftBukkit end
 
 public class DedicatedServer extends MinecraftServer implements IMinecraftServer {
 
     private static final Logger LOGGER = LogManager.getLogger();
-    private final List<ServerCommand> l = Collections.synchronizedList(Lists.<ServerCommand>newArrayList()); // CraftBukkit - fix decompile error
+    private final List<ServerCommand> l = Collections.synchronizedList(Lists.newArrayList()); // CraftBukkit - fix decompile error
     private RemoteStatusListener m;
     private RemoteControlListener n;
     public PropertyManager propertyManager;
@@ -52,8 +51,7 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
                 while (true) {
                     try {
                         Thread.sleep(2147483647L);
-                    } catch (InterruptedException interruptedexception) {
-                        ;
+                    } catch (InterruptedException ignored) {
                     }
                 }
             }
@@ -124,12 +122,11 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
         this.propertyManager = new PropertyManager(this.options); // CraftBukkit - CLI argument support
         this.p = new EULA(new File("eula.txt"));
         // Spigot Start
-        boolean eulaAgreed = Boolean.getBoolean( "com.mojang.eula.agree" );
-        if ( eulaAgreed )
-        {
-            System.err.println( "You have used the Spigot command line EULA agreement flag." );
-            System.err.println( "By using this setting you are indicating your agreement to Mojang's EULA (https://account.mojang.com/documents/minecraft_eula)." );
-            System.err.println( "If you do not agree to the above EULA please stop your server and remove this flag immediately." );
+        boolean eulaAgreed = Boolean.getBoolean("com.mojang.eula.agree");
+        if (eulaAgreed) {
+            System.err.println("You have used the Spigot command line EULA agreement flag.");
+            System.err.println("By using this setting you are indicating your agreement to Mojang's EULA (https://account.mojang.com/documents/minecraft_eula).");
+            System.err.println("If you do not agree to the above EULA please stop your server and remove this flag immediately.");
         }
         // Spigot End
         if (!this.p.a() && !eulaAgreed) { // Spigot
@@ -173,7 +170,7 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
                 this.setPort(this.propertyManager.getInt("server-port", 25565));
             }
             // Spigot start
-            this.a((PlayerList) (new DedicatedPlayerList(this)));
+            this.a(new DedicatedPlayerList(this));
             org.spigotmc.SpigotConfig.init((File) options.valueOf("spigot-settings"));
             org.spigotmc.SpigotConfig.registerCommands();
             // Spigot end
@@ -186,16 +183,16 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
             this.a(MinecraftEncryption.b());
             DedicatedServer.LOGGER.info("Starting Minecraft server on " + (this.getServerIp().length() == 0 ? "*" : this.getServerIp()) + ":" + this.R());
 
-        if (!org.spigotmc.SpigotConfig.lateBind) {
-            try {
-                this.aq().a(inetaddress, this.R());
-            } catch (IOException ioexception) {
-                DedicatedServer.LOGGER.warn("**** FAILED TO BIND TO PORT!");
-                DedicatedServer.LOGGER.warn("The exception was: {}", new Object[] { ioexception.toString()});
-                DedicatedServer.LOGGER.warn("Perhaps a server is already running on that port?");
-                return false;
+            if (!org.spigotmc.SpigotConfig.lateBind) {
+                try {
+                    this.aq().a(inetaddress, this.R());
+                } catch (IOException ioexception) {
+                    DedicatedServer.LOGGER.warn("**** FAILED TO BIND TO PORT!");
+                    DedicatedServer.LOGGER.warn("The exception was: {}", ioexception.toString());
+                    DedicatedServer.LOGGER.warn("Perhaps a server is already running on that port?");
+                    return false;
+                }
             }
-        }
 
             // Spigot Start - Move DedicatedPlayerList up and bring plugin loading from CraftServer to here
             // this.a((PlayerList) (new DedicatedPlayerList(this))); // CraftBukkit
@@ -262,11 +259,11 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
                 this.c(this.propertyManager.getInt("max-build-height", 256));
                 this.c((this.getMaxBuildHeight() + 8) / 16 * 16);
                 this.c(MathHelper.clamp(this.getMaxBuildHeight(), 64, 256));
-                this.propertyManager.setProperty("max-build-height", Integer.valueOf(this.getMaxBuildHeight()));
+                this.propertyManager.setProperty("max-build-height", this.getMaxBuildHeight());
                 DedicatedServer.LOGGER.info("Preparing level \"" + this.U() + "\"");
                 this.a(this.U(), this.U(), k, worldtype, s2);
                 long i1 = System.nanoTime() - j;
-                String s3 = String.format("%.3fs", new Object[] { Double.valueOf((double) i1 / 1.0E9D)});
+                String s3 = String.format("%.3fs", (double) i1 / 1.0E9D);
 
                 DedicatedServer.LOGGER.info("Done (" + s3 + ")! For help, type \"help\" or \"?\"");
                 if (this.propertyManager.getBoolean("enable-query", false)) {
@@ -292,23 +289,15 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
                 }
                 // CraftBukkit end
 
-        if (org.spigotmc.SpigotConfig.lateBind) {
-            try {
-                this.aq().a(inetaddress, this.R());
-            } catch (IOException ioexception) {
-                DedicatedServer.LOGGER.warn("**** FAILED TO BIND TO PORT!");
-                DedicatedServer.LOGGER.warn("The exception was: {}", new Object[] { ioexception.toString()});
-                DedicatedServer.LOGGER.warn("Perhaps a server is already running on that port?");
-                return false;
-            }
-        }
-
-                if (false && this.aS() > 0L) {  // Spigot - disable
-                    Thread thread1 = new Thread(new ThreadWatchdog(this));
-
-                    thread1.setName("Server Watchdog");
-                    thread1.setDaemon(true);
-                    thread1.start();
+                if (org.spigotmc.SpigotConfig.lateBind) {
+                    try {
+                        this.aq().a(inetaddress, this.R());
+                    } catch (IOException ioexception) {
+                        DedicatedServer.LOGGER.warn("**** FAILED TO BIND TO PORT!");
+                        DedicatedServer.LOGGER.warn("The exception was: {}", ioexception.toString());
+                        DedicatedServer.LOGGER.warn("Perhaps a server is already running on that port?");
+                        return false;
+                    }
                 }
 
                 return true;
@@ -343,30 +332,13 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
         return this.propertyManager.getBoolean("hardcore", false);
     }
 
-    protected void a(CrashReport crashreport) {}
+    protected void a(CrashReport crashreport) {
+    }
 
     public CrashReport b(CrashReport crashreport) {
         crashreport = super.b(crashreport);
-        crashreport.g().a("Is Modded", new Callable() {
-            public String a() throws Exception {
-                String s = DedicatedServer.this.getServerModName();
-
-                return !s.equals("vanilla") ? "Definitely; Server brand changed to \'" + s + "\'" : "Unknown (can\'t tell)";
-            }
-
-            public Object call() throws Exception {
-                return this.a();
-            }
-        });
-        crashreport.g().a("Type", new Callable() {
-            public String a() throws Exception {
-                return "Dedicated Server (map_server.txt)";
-            }
-
-            public Object call() throws Exception {
-                return this.a();
-            }
-        });
+        crashreport.g().a("Is Modded", () -> !DedicatedServer.this.getServerModName().equals("vanilla") ? "Definitely; Server brand changed to \'" + DedicatedServer.this.getServerModName() + "\'" : "Unknown (can\'t tell)");
+        crashreport.g().a("Type", () -> "Dedicated Server (map_server.txt)");
         return crashreport;
     }
 
@@ -388,8 +360,8 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
     }
 
     public void a(MojangStatisticsGenerator mojangstatisticsgenerator) {
-        mojangstatisticsgenerator.a("whitelist_enabled", Boolean.valueOf(this.aP().getHasWhitelist()));
-        mojangstatisticsgenerator.a("whitelist_count", Integer.valueOf(this.aP().getWhitelisted().length));
+        mojangstatisticsgenerator.a("whitelist_enabled", this.aP().getHasWhitelist());
+        mojangstatisticsgenerator.a("whitelist_count", this.aP().getWhitelisted().length);
         super.a(mojangstatisticsgenerator);
     }
 
@@ -404,7 +376,7 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
     public void aO() {
         SpigotTimings.serverCommandTimer.startTiming(); // Spigot
         while (!this.l.isEmpty()) {
-            ServerCommand servercommand = (ServerCommand) this.l.remove(0);
+            ServerCommand servercommand = this.l.remove(0);
 
             // CraftBukkit start - ServerCommand for preprocessing
             ServerCommandEvent event = new ServerCommandEvent(console, servercommand.command);
@@ -480,22 +452,15 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
     }
 
     public boolean a(World world, BlockPosition blockposition, EntityHuman entityhuman) {
-        if (world.worldProvider.getDimension() != 0) {
-            return false;
-        } else if (this.aP().getOPs().isEmpty()) {
+        if (world.worldProvider.getDimension() != 0 || this.aP().getOPs().isEmpty() || this.aP().isOp(entityhuman.getProfile()) || this.getSpawnProtection() <= 0) {
             return false;
-        } else if (this.aP().isOp(entityhuman.getProfile())) {
-            return false;
-        } else if (this.getSpawnProtection() <= 0) {
-            return false;
-        } else {
-            BlockPosition blockposition1 = world.getSpawn();
-            int i = MathHelper.a(blockposition.getX() - blockposition1.getX());
-            int j = MathHelper.a(blockposition.getZ() - blockposition1.getZ());
-            int k = Math.max(i, j);
-
-            return k <= this.getSpawnProtection();
         }
+        BlockPosition blockposition1 = world.getSpawn();
+        int i = MathHelper.a(blockposition.getX() - blockposition1.getX());
+        int j = MathHelper.a(blockposition.getZ() - blockposition1.getZ());
+        int k = Math.max(i, j);
+
+        return k <= this.getSpawnProtection();
     }
 
     public int p() {
@@ -504,7 +469,7 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
 
     public void setIdleTimeout(int i) {
         super.setIdleTimeout(i);
-        this.propertyManager.setProperty("player-idle-timeout", Integer.valueOf(i));
+        this.propertyManager.setProperty("player-idle-timeout", i);
         this.a();
     }
 
@@ -537,7 +502,7 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
     }
 
     protected boolean aR() {
-        server.getLogger().info( "**** Beginning UUID conversion, this may take A LONG time ****"); // Spigot, let the user know whats up!
+        server.getLogger().info("**** Beginning UUID conversion, this may take A LONG time ****"); // Spigot, let the user know whats up!
         boolean flag = false;
 
         int i;
@@ -548,7 +513,7 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
                 this.aU();
             }
 
-            flag = NameReferencingFileConverter.a((MinecraftServer) this);
+            flag = NameReferencingFileConverter.a(this);
         }
 
         boolean flag1 = false;
@@ -559,7 +524,7 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
                 this.aU();
             }
 
-            flag1 = NameReferencingFileConverter.b((MinecraftServer) this);
+            flag1 = NameReferencingFileConverter.b(this);
         }
 
         boolean flag2 = false;
@@ -570,7 +535,7 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
                 this.aU();
             }
 
-            flag2 = NameReferencingFileConverter.c((MinecraftServer) this);
+            flag2 = NameReferencingFileConverter.c(this);
         }
 
         boolean flag3 = false;
@@ -581,7 +546,7 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
                 this.aU();
             }
 
-            flag3 = NameReferencingFileConverter.d((MinecraftServer) this);
+            flag3 = NameReferencingFileConverter.d(this);
         }
 
         boolean flag4 = false;
@@ -602,7 +567,6 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
         try {
             Thread.sleep(5000L);
         } catch (InterruptedException interruptedexception) {
-            ;
         }
     }
 
diff --git a/src/main/java/net/minecraft/server/EntityTracker.java b/src/main/java/net/minecraft/server/EntityTracker.java
index cb72b3672..211864c14 100644
--- a/src/main/java/net/minecraft/server/EntityTracker.java
+++ b/src/main/java/net/minecraft/server/EntityTracker.java
@@ -2,12 +2,13 @@ package net.minecraft.server;
 
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.Set;
 import java.util.concurrent.Callable;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
 
 public class EntityTracker {
 
@@ -94,7 +95,7 @@ public class EntityTracker {
     }
 
     public void addEntity(Entity entity, int i, final int j, boolean flag) {
-        org.spigotmc.AsyncCatcher.catchOp( "entity track"); // Spigot
+        org.spigotmc.AsyncCatcher.catchOp("entity track"); // Spigot
         i = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, i); // Spigot
         if (i > this.e) {
             i = this.e;
@@ -114,7 +115,7 @@ public class EntityTracker {
             CrashReport crashreport = CrashReport.a(throwable, "Adding entity to track");
             CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity To Track");
 
-            crashreportsystemdetails.a("Tracking range", (Object) (i + " blocks"));
+            crashreportsystemdetails.a("Tracking range", i + " blocks");
             final int finalI = i; // CraftBukkit - fix decompile error
             crashreportsystemdetails.a("Update interval", new Callable() {
                 public String a() throws Exception {
@@ -134,7 +135,7 @@ public class EntityTracker {
             entity.appendEntityCrashDetails(crashreportsystemdetails);
             CrashReportSystemDetails crashreportsystemdetails1 = crashreport.a("Entity That Is Already Tracked");
 
-            ((EntityTrackerEntry) this.trackedEntities.get(entity.getId())).tracker.appendEntityCrashDetails(crashreportsystemdetails1);
+            this.trackedEntities.get(entity.getId()).tracker.appendEntityCrashDetails(crashreportsystemdetails1);
 
             try {
                 throw new ReportedException(crashreport);
@@ -146,7 +147,7 @@ public class EntityTracker {
     }
 
     public void untrackEntity(Entity entity) {
-        org.spigotmc.AsyncCatcher.catchOp( "entity untrack"); // Spigot
+        org.spigotmc.AsyncCatcher.catchOp("entity untrack"); // Spigot
         if (entity instanceof EntityPlayer) {
             EntityPlayer entityplayer = (EntityPlayer) entity;
             Iterator iterator = this.c.iterator();
@@ -158,7 +159,7 @@ public class EntityTracker {
             }
         }
 
-        EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) this.trackedEntities.d(entity.getId());
+        EntityTrackerEntry entitytrackerentry1 = this.trackedEntities.d(entity.getId());
 
         if (entitytrackerentry1 != null) {
             this.c.remove(entitytrackerentry1);
@@ -169,24 +170,18 @@ public class EntityTracker {
 
     public void updatePlayers() {
         ArrayList arraylist = Lists.newArrayList();
-        Iterator iterator = this.c.iterator();
-
-        while (iterator.hasNext()) {
-            EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) iterator.next();
 
+        for (EntityTrackerEntry entitytrackerentry : this.c) {
             entitytrackerentry.track(this.world.players);
             if (entitytrackerentry.n && entitytrackerentry.tracker instanceof EntityPlayer) {
-                arraylist.add((EntityPlayer) entitytrackerentry.tracker);
+                arraylist.add(entitytrackerentry.tracker);
             }
         }
 
-        for (int i = 0; i < arraylist.size(); ++i) {
-            EntityPlayer entityplayer = (EntityPlayer) arraylist.get(i);
-            Iterator iterator1 = this.c.iterator();
-
-            while (iterator1.hasNext()) {
-                EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) iterator1.next();
+        for (Object o : arraylist) {
+            EntityPlayer entityplayer = (EntityPlayer) o;
 
+            for (EntityTrackerEntry entitytrackerentry1 : this.c) {
                 if (entitytrackerentry1.tracker != entityplayer) {
                     entitytrackerentry1.updatePlayer(entityplayer);
                 }
@@ -211,7 +206,7 @@ public class EntityTracker {
     }
 
     public void a(Entity entity, Packet packet) {
-        EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) this.trackedEntities.get(entity.getId());
+        EntityTrackerEntry entitytrackerentry = this.trackedEntities.get(entity.getId());
 
         if (entitytrackerentry != null) {
             entitytrackerentry.broadcast(packet);
@@ -220,7 +215,7 @@ public class EntityTracker {
     }
 
     public void sendPacketToEntity(Entity entity, Packet packet) {
-        EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) this.trackedEntities.get(entity.getId());
+        EntityTrackerEntry entitytrackerentry = this.trackedEntities.get(entity.getId());
 
         if (entitytrackerentry != null) {
             entitytrackerentry.broadcastIncludingSelf(packet);
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 699996143..da76f8b7d 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -1,8 +1,8 @@
 package net.minecraft.server;
 
+import co.aikar.timings.SpigotTimings;
 import com.google.common.base.Charsets;
 import com.google.common.collect.Lists;
-import com.google.common.collect.Queues;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.ListenableFutureTask;
@@ -14,38 +14,29 @@ import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufOutputStream;
 import io.netty.buffer.Unpooled;
 import io.netty.handler.codec.base64.Base64;
-import java.awt.GraphicsEnvironment;
+import jline.console.ConsoleReader;
+import joptsimple.OptionSet;
+import org.apache.commons.lang3.Validate;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.craftbukkit.Main;
+
+import javax.imageio.ImageIO;
+import java.awt.*;
 import java.awt.image.BufferedImage;
 import java.io.File;
 import java.io.IOException;
 import java.net.Proxy;
 import java.security.KeyPair;
 import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Date;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Queue;
-import java.util.Random;
-import java.util.UUID;
+import java.util.*;
 import java.util.concurrent.Callable;
 import java.util.concurrent.Executors;
 import java.util.concurrent.FutureTask;
-import javax.imageio.ImageIO;
-import org.apache.commons.lang3.Validate;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
 
 // CraftBukkit start
-import java.io.IOException;
-
-import jline.console.ConsoleReader;
-import joptsimple.OptionSet;
-
-import org.bukkit.craftbukkit.Main;
-import co.aikar.timings.SpigotTimings; // Spigot
 // CraftBukkit end
 
 public abstract class MinecraftServer implements Runnable, ICommandListener, IAsyncTaskHandler, IMojangStatistics {
@@ -113,12 +104,12 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
     public ConsoleReader reader;
     public static int currentTick = 0; // PaperSpigot - Further improve tick loop
     public final Thread primaryThread;
-    public java.util.Queue<Runnable> processQueue = new java.util.concurrent.ConcurrentLinkedQueue<Runnable>();
+    public java.util.Queue<Runnable> processQueue = new java.util.concurrent.ConcurrentLinkedQueue<>();
     public int autosavePeriod;
     // CraftBukkit end
 
     public MinecraftServer(OptionSet options, Proxy proxy, File file1) {
-        io.netty.util.ResourceLeakDetector.setEnabled( false ); // Spigot - disable
+        io.netty.util.ResourceLeakDetector.setEnabled(false); // Spigot - disable
         this.e = proxy;
         MinecraftServer.l = this;
         // this.universe = file; // CraftBukkit
@@ -173,7 +164,8 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
             this.getConvertable().convert(s, new IProgressUpdate() {
                 private long b = System.currentTimeMillis();
 
-                public void a(String s) {}
+                public void a(String s) {
+                }
 
                 public void a(int i) {
                     if (System.currentTimeMillis() - this.b >= 1000L) {
@@ -183,7 +175,8 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
 
                 }
 
-                public void c(String s) {}
+                public void c(String s) {
+                }
             });
         }
 
@@ -408,14 +401,13 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
         this.server.enablePlugins(org.bukkit.plugin.PluginLoadOrder.POSTWORLD); // CraftBukkit
     }
 
-    protected void saveChunks(boolean flag) throws ExceptionWorldConflict { // CraftBukkit - added throws
+    protected void saveChunks(boolean flag) { // CraftBukkit - added throws
         if (!this.N) {
             WorldServer[] aworldserver = this.worldServer;
             int i = aworldserver.length;
 
             // CraftBukkit start
-            for (int j = 0; j < worlds.size(); ++j) {
-                WorldServer worldserver = worlds.get(j);
+            for (WorldServer worldserver : worlds) {
                 // CraftBukkit end
 
                 if (worldserver != null) {
@@ -424,7 +416,7 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
                     }
 
                     try {
-                        worldserver.save(true, (IProgressUpdate) null);
+                        worldserver.save(true, null);
                         worldserver.saveLevel(); // CraftBukkit
                     } catch (ExceptionWorldConflict exceptionworldconflict) {
                         MinecraftServer.LOGGER.warn(exceptionworldconflict.getMessage());
@@ -442,7 +434,7 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
 
     public void stop() throws ExceptionWorldConflict { // CraftBukkit - added throws
         // CraftBukkit start - prevent double stopping on multiple threads
-        synchronized(stopLock) {
+        synchronized (stopLock) {
             if (hasStopped) return;
             hasStopped = true;
         }
@@ -464,7 +456,10 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
                 MinecraftServer.LOGGER.info("Saving players");
                 this.v.savePlayers();
                 this.v.u();
-                try { Thread.sleep(100); } catch (InterruptedException ex) {} // CraftBukkit - SPIGOT-625 - give server at least a chance to send packets
+                try {
+                    Thread.sleep(100);
+                } catch (InterruptedException ignored) {
+                } // CraftBukkit - SPIGOT-625 - give server at least a chance to send packets
             }
 
             if (this.worldServer != null) {
@@ -484,8 +479,7 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
                 this.n.e();
             }
             // Spigot start
-            if( org.spigotmc.SpigotConfig.saveUserCacheOnStopOnly )
-            {
+            if (org.spigotmc.SpigotConfig.saveUserCacheOnStopOnly) {
                 LOGGER.info("Saving usercache.json");
                 this.Z.c();
             }
@@ -510,15 +504,16 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
     }
 
     // PaperSpigot start - Further improve tick loop
-    private static final int TPS = 20;
+    private static final int TPS = 40;
     private static final long SEC_IN_NANO = 1000000000;
     private static final long TICK_TIME = SEC_IN_NANO / TPS;
     private static final long MAX_CATCHUP_BUFFER = TICK_TIME * TPS * 60L;
-    private static final int SAMPLE_INTERVAL = 20;
+    private static final int SAMPLE_INTERVAL = 40;
     public final RollingAverage tps1 = new RollingAverage(60);
     public final RollingAverage tps5 = new RollingAverage(60 * 5);
     public final RollingAverage tps15 = new RollingAverage(60 * 15);
-    public double[] recentTps = new double[ 3 ]; // PaperSpigot - Fine have your darn compat with bad plugins
+    private boolean offTick = true;
+    public double[] recentTps = new double[3]; // PaperSpigot - Fine have your darn compat with bad plugins
 
     public static class RollingAverage {
         private final int size;
@@ -562,15 +557,14 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
         try {
             if (this.init()) {
                 this.ab = az();
-                long i = 0L;
 
                 this.r.setMOTD(new ChatComponentText(this.motd));
-                this.r.setServerInfo(new ServerPing.ServerData("1.8.8", 47));
+                this.r.setServerInfo(new ServerPing.ServerData("LockedSpigot", 47));
                 this.a(this.r);
 
                 // Spigot start
                 // PaperSpigot start - Further improve tick loop
-                Arrays.fill( recentTps, 20 );
+                Arrays.fill(recentTps, 20);
                 //long lastTick = System.nanoTime(), catchupTime = 0, curTime, wait, tickSection = lastTick;
                 long start = System.nanoTime(), lastTick = start - TICK_TIME, catchupTime = 0, curTime, wait, tickSection = start;
                 // PaperSpigot end
@@ -599,8 +593,7 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
 
                     catchupTime = Math.min(MAX_CATCHUP_BUFFER, catchupTime - wait);
 
-                    if ( ++MinecraftServer.currentTick % SAMPLE_INTERVAL == 0 )
-                    {
+                    if (++MinecraftServer.currentTick % SAMPLE_INTERVAL == 0) {
                         final long diff = curTime - tickSection;
                         double currentTps = 1E9 / diff * SAMPLE_INTERVAL;
                         tps1.add(currentTps, diff);
@@ -625,9 +618,8 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
         } catch (Throwable throwable) {
             MinecraftServer.LOGGER.error("Encountered an unexpected exception", throwable);
             // Spigot Start
-            if ( throwable.getCause() != null )
-            {
-                MinecraftServer.LOGGER.error( "\tCause of unexpected exception was", throwable.getCause() );
+            if (throwable.getCause() != null) {
+                MinecraftServer.LOGGER.error("\tCause of unexpected exception was", throwable.getCause());
             }
             // Spigot End
             CrashReport crashreport = null;
@@ -677,8 +669,8 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
             try {
                 BufferedImage bufferedimage = ImageIO.read(file);
 
-                Validate.validState(bufferedimage.getWidth() == 64, "Must be 64 pixels wide", new Object[0]);
-                Validate.validState(bufferedimage.getHeight() == 64, "Must be 64 pixels high", new Object[0]);
+                Validate.validState(bufferedimage.getWidth() == 64, "Must be 64 pixels wide");
+                Validate.validState(bufferedimage.getHeight() == 64, "Must be 64 pixels high");
                 ImageIO.write(bufferedimage, "PNG", new ByteBufOutputStream(bytebuf));
                 ByteBuf bytebuf1 = Base64.encode(bytebuf);
 
@@ -696,9 +688,11 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
         return new File(".");
     }
 
-    protected void a(CrashReport crashreport) {}
+    protected void a(CrashReport crashreport) {
+    }
 
-    protected void z() {}
+    protected void z() {
+    }
 
     protected void A() throws ExceptionWorldConflict { // CraftBukkit - added throws
         co.aikar.timings.TimingsManager.FULL_SERVER_TICK.startTiming(); // Spigot
@@ -720,7 +714,7 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
             int j = MathHelper.nextInt(this.s, 0, this.I() - agameprofile.length);
 
             for (int k = 0; k < agameprofile.length; ++k) {
-                agameprofile[k] = ((EntityPlayer) this.v.v().get(j + k)).getProfile();
+                agameprofile[k] = this.v.v().get(j + k).getProfile();
             }
 
             Collections.shuffle(Arrays.asList(agameprofile));
@@ -765,26 +759,21 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
     }
 
     public void B() {
+        this.offTick = !offTick;
         SpigotTimings.minecraftSchedulerTimer.startTiming(); // Spigot
         this.methodProfiler.a("jobs");
-        Queue queue = this.j;
 
         // Spigot start
         FutureTask<?> entry;
         int count = this.j.size();
         while (count-- > 0 && (entry = this.j.poll()) != null) {
             SystemUtils.a(entry, MinecraftServer.LOGGER);
-         }
+        }
         // Spigot end
         SpigotTimings.minecraftSchedulerTimer.stopTiming(); // Spigot
 
         this.methodProfiler.c("levels");
 
-        SpigotTimings.bukkitSchedulerTimer.startTiming(); // Spigot
-        // CraftBukkit start
-        this.server.getScheduler().mainThreadHeartbeat(this.ticks);
-        SpigotTimings.bukkitSchedulerTimer.stopTiming(); // Spigot
-
         // Run tasks that are waiting on processing
         SpigotTimings.processQueueTimer.startTiming(); // Spigot
         while (!processQueue.isEmpty()) {
@@ -798,23 +787,28 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
 
         SpigotTimings.timeUpdateTimer.startTiming(); // Spigot
         // Send time updates to everyone, it will get the right time from the world the player is in.
-        if (this.ticks % 20 == 0) {
+        if (this.ticks % 40 == 0) {
             for (int i = 0; i < this.getPlayerList().players.size(); ++i) {
-                EntityPlayer entityplayer = (EntityPlayer) this.getPlayerList().players.get(i);
+                EntityPlayer entityplayer = this.getPlayerList().players.get(i);
                 entityplayer.playerConnection.sendPacket(new PacketPlayOutUpdateTime(entityplayer.world.getTime(), entityplayer.getPlayerTime(), entityplayer.world.getGameRules().getBoolean("doDaylightCycle"))); // Add support for per player time
             }
         }
         SpigotTimings.timeUpdateTimer.stopTiming(); // Spigot
 
+        if (offTick) {
+            SpigotTimings.bukkitSchedulerTimer.startTiming(); // Spigot
+            // CraftBukkit start
+            this.server.getScheduler().mainThreadHeartbeat(this.ticks);
+            SpigotTimings.bukkitSchedulerTimer.stopTiming(); // Spigot
+        }
+
         int i;
 
         for (i = 0; i < this.worlds.size(); ++i) {
-            long j = System.nanoTime();
-
             // if (i == 0 || this.getAllowNether()) {
-                WorldServer worldserver = this.worlds.get(i);
+            WorldServer worldserver = this.worlds.get(i);
 
-                this.methodProfiler.a(worldserver.getWorldData().getName());
+            this.methodProfiler.a(worldserver.getWorldData().getName());
                 /* Drop global time updates
                 if (this.ticks % 20 == 0) {
                     this.methodProfiler.a("timeSync");
@@ -823,26 +817,27 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
                 }
                 // CraftBukkit end */
 
-                this.methodProfiler.a("tick");
+            this.methodProfiler.a("tick");
 
-                CrashReport crashreport;
+            CrashReport crashreport;
 
+            try {
+                worldserver.timings.doTick.startTiming(); // Spigot
+                worldserver.doTick();
+                worldserver.timings.doTick.stopTiming(); // Spigot
+            } catch (Throwable throwable) {
+                // Spigot Start
                 try {
-                    worldserver.timings.doTick.startTiming(); // Spigot
-                    worldserver.doTick();
-                    worldserver.timings.doTick.stopTiming(); // Spigot
-                } catch (Throwable throwable) {
-                    // Spigot Start
-                    try {
                     crashreport = CrashReport.a(throwable, "Exception ticking world");
-                    } catch (Throwable t){
-                        throw new RuntimeException("Error generating crash report", t);
-                    }
-                    // Spigot End
-                    worldserver.a(crashreport);
-                    throw new ReportedException(crashreport);
+                } catch (Throwable t) {
+                    throw new RuntimeException("Error generating crash report", t);
                 }
+                // Spigot End
+                worldserver.a(crashreport);
+                throw new ReportedException(crashreport);
+            }
 
+            if (offTick) {
                 try {
                     worldserver.timings.tickEntities.startTiming(); // Spigot
                     worldserver.tickEntities();
@@ -850,23 +845,45 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
                 } catch (Throwable throwable1) {
                     // Spigot Start
                     try {
-                    crashreport = CrashReport.a(throwable1, "Exception ticking world entities");
-                    } catch (Throwable t){
+                        crashreport = CrashReport.a(throwable1, "Exception ticking world entities");
+                    } catch (Throwable t) {
                         throw new RuntimeException("Error generating crash report", t);
                     }
                     // Spigot End
                     worldserver.a(crashreport);
                     throw new ReportedException(crashreport);
                 }
+            }
+
+            /*
+
+            Moved to 20tps
+
+            try {
+                worldserver.timings.tickEntities.startTiming(); // Spigot
+                worldserver.tickEntities();
+                worldserver.timings.tickEntities.stopTiming(); // Spigot
+            } catch (Throwable throwable1) {
+                // Spigot Start
+                try {
+                    crashreport = CrashReport.a(throwable1, "Exception ticking world entities");
+                } catch (Throwable t) {
+                    throw new RuntimeException("Error generating crash report", t);
+                }
+                // Spigot End
+                worldserver.a(crashreport);
+                throw new ReportedException(crashreport);
+            }
 
-                this.methodProfiler.b();
-                this.methodProfiler.a("tracker");
-                worldserver.timings.tracker.startTiming(); // Spigot
-                worldserver.getTracker().updatePlayers();
-                worldserver.timings.tracker.stopTiming(); // Spigot
-                this.methodProfiler.b();
-                this.methodProfiler.b();
-                worldserver.explosionDensityCache.clear(); // PaperSpigot - Optimize explosions
+             */
+            this.methodProfiler.b();
+            this.methodProfiler.a("tracker");
+            worldserver.timings.tracker.startTiming(); // Spigot
+            worldserver.getTracker().updatePlayers();
+            worldserver.timings.tracker.stopTiming(); // Spigot
+            this.methodProfiler.b();
+            this.methodProfiler.b();
+            worldserver.explosionDensityCache.clear(); // PaperSpigot - Optimize explosions
             // } // CraftBukkit
 
             // this.i[i][this.ticks % 100] = System.nanoTime() - j; // CraftBukkit
@@ -884,7 +901,7 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
 
         SpigotTimings.tickablesTimer.startTiming(); // Spigot
         for (i = 0; i < this.p.size(); ++i) {
-            ((IUpdatePlayerListBox) this.p.get(i)).c();
+            this.p.get(i).c();
         }
         SpigotTimings.tickablesTimer.stopTiming(); // Spigot
 
@@ -1425,10 +1442,10 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
     }
 
     // Spigot Start
-    public ServerConnection getServerConnection()
-    {
+    public ServerConnection getServerConnection() {
         return this.q;
     }
+
     // Spigot End
     public ServerConnection aq() {
         return this.q == null ? this.q = new ServerConnection(this) : this.q; // Spigot
@@ -1549,7 +1566,8 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
         return getServer().worlds.get(0).getGameRules().getBoolean("sendCommandFeedback");
     }
 
-    public void a(CommandObjectiveExecutor.EnumCommandResult commandobjectiveexecutor_enumcommandresult, int i) {}
+    public void a(CommandObjectiveExecutor.EnumCommandResult commandobjectiveexecutor_enumcommandresult, int i) {
+    }
 
     public int aI() {
         return 29999984;
diff --git a/src/main/java/net/minecraft/server/ServerStatisticManager.java b/src/main/java/net/minecraft/server/ServerStatisticManager.java
index 22c2ffddf..79fb391fd 100644
--- a/src/main/java/net/minecraft/server/ServerStatisticManager.java
+++ b/src/main/java/net/minecraft/server/ServerStatisticManager.java
@@ -188,12 +188,9 @@ public class ServerStatisticManager extends StatisticManager {
 
         if (this.g || i - this.f > 300) {
             this.f = i;
-            Iterator iterator = this.c().iterator();
 
-            while (iterator.hasNext()) {
-                Statistic statistic = (Statistic) iterator.next();
-
-                hashmap.put(statistic, Integer.valueOf(this.getStatisticValue(statistic)));
+            for (Statistic statistic : this.c()) {
+                hashmap.put(statistic, this.getStatisticValue(statistic));
             }
         }
 
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index d4f337e22..c7282e846 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -4,26 +4,26 @@ import com.google.common.base.Predicate;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import org.bukkit.Bukkit;
 import org.bukkit.block.BlockState;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
-import org.bukkit.craftbukkit.util.LongHashSet;
 import org.bukkit.event.block.BlockCanBuildEvent;
 import org.bukkit.event.block.BlockPhysicsEvent;
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
 import org.bukkit.generator.ChunkGenerator;
-import co.aikar.timings.SpigotTimings;
 
 import java.util.*;
 import java.util.concurrent.Callable;
-
-// PaperSpigot start
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
-import com.google.common.util.concurrent.ThreadFactoryBuilder;
+
+// PaperSpigot start
+
+// PaperSpigot start
 // PaperSpigot end
 
 // CraftBukkit start
@@ -34,26 +34,21 @@ public abstract class World implements IBlockAccess {
     private int a = 63;
     protected boolean e;
     // Spigot start - guard entity list from removals
-    public final List<Entity> entityList = new java.util.ArrayList<Entity>()
-    {
+    public final List<Entity> entityList = new java.util.ArrayList<Entity>() {
         @Override
-        public Entity remove(int index)
-        {
+        public Entity remove(int index) {
             guard();
-            return super.remove( index );
+            return super.remove(index);
         }
 
         @Override
-        public boolean remove(Object o)
-        {
+        public boolean remove(Object o) {
             guard();
-            return super.remove( o );
+            return super.remove(o);
         }
 
-        private void guard()
-        {
-            if ( guardEntityList )
-            {
+        private void guard() {
+            if (guardEntityList) {
                 throw new java.util.ConcurrentModificationException();
             }
         }
@@ -106,18 +101,18 @@ public abstract class World implements IBlockAccess {
 
     public boolean captureBlockStates = false;
     public boolean captureTreeGeneration = false;
-    public ArrayList<BlockState> capturedBlockStates= new ArrayList<BlockState>(){
+    public ArrayList<BlockState> capturedBlockStates = new ArrayList<BlockState>() {
         @Override
-        public boolean add( BlockState blockState ) {
+        public boolean add(BlockState blockState) {
             Iterator<BlockState> blockStateIterator = this.iterator();
-            while( blockStateIterator.hasNext() ) {
+            while (blockStateIterator.hasNext()) {
                 BlockState blockState1 = blockStateIterator.next();
-                if ( blockState1.getLocation().equals( blockState.getLocation() ) ) {
+                if (blockState1.getLocation().equals(blockState.getLocation())) {
                     return false;
                 }
             }
 
-            return super.add( blockState );
+            return super.add(blockState);
         }
     };
     public long ticksPerAnimalSpawns;
@@ -139,21 +134,18 @@ public abstract class World implements IBlockAccess {
     public ExecutorService lightingExecutor = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder().setNameFormat("PaperSpigot - Lighting Thread").build()); // PaperSpigot - Asynchronous lighting updates
     public final Map<Explosion.CacheKey, Float> explosionDensityCache = new HashMap<Explosion.CacheKey, Float>(); // PaperSpigot - Optimize explosions
 
-    public static long chunkToKey(int x, int z)
-    {
-        long k = ( ( ( (long) x ) & 0xFFFF0000L ) << 16 ) | ( ( ( (long) x ) & 0x0000FFFFL ) << 0 );
-        k |= ( ( ( (long) z ) & 0xFFFF0000L ) << 32 ) | ( ( ( (long) z ) & 0x0000FFFFL ) << 16 );
+    public static long chunkToKey(int x, int z) {
+        long k = ((((long) x) & 0xFFFF0000L) << 16) | ((((long) x) & 0x0000FFFFL) << 0);
+        k |= ((((long) z) & 0xFFFF0000L) << 32) | ((((long) z) & 0x0000FFFFL) << 16);
         return k;
     }
 
-    public static int keyToX(long k)
-    {
-        return (int) ( ( ( k >> 16 ) & 0xFFFF0000 ) | ( k & 0x0000FFFF ) );
+    public static int keyToX(long k) {
+        return (int) (((k >> 16) & 0xFFFF0000) | (k & 0x0000FFFF));
     }
 
-    public static int keyToZ(long k)
-    {
-        return (int) ( ( ( k >> 32 ) & 0xFFFF0000L ) | ( ( k >> 16 ) & 0x0000FFFF ) );
+    public static int keyToZ(long k) {
+        return (int) (((k >> 32) & 0xFFFF0000L) | ((k >> 16) & 0x0000FFFF));
     }
     // Spigot end
 
@@ -177,8 +169,8 @@ public abstract class World implements IBlockAccess {
     }
 
     protected World(IDataManager idatamanager, WorldData worlddata, WorldProvider worldprovider, MethodProfiler methodprofiler, boolean flag, ChunkGenerator gen, org.bukkit.World.Environment env) {
-        this.spigotConfig = new org.spigotmc.SpigotWorldConfig( worlddata.getName() ); // Spigot
-        this.paperSpigotConfig = new org.github.paperspigot.PaperSpigotWorldConfig( worlddata.getName() ); // PaperSpigot
+        this.spigotConfig = new org.spigotmc.SpigotWorldConfig(worlddata.getName()); // Spigot
+        this.paperSpigotConfig = new org.github.paperspigot.PaperSpigotWorldConfig(worlddata.getName()); // PaperSpigot
         this.tacoSpigotConfig = new net.techcable.tacospigot.TacoSpigotWorldConfig(worlddata.getName()); // TacoSpigot
         this.generator = gen;
         this.world = new CraftWorld((WorldServer) this, gen, env);
@@ -186,9 +178,9 @@ public abstract class World implements IBlockAccess {
         this.ticksPerMonsterSpawns = this.getServer().getTicksPerMonsterSpawns(); // CraftBukkit
         // CraftBukkit end
         // Spigot start
-        this.chunkTickRadius = (byte) ( ( this.getServer().getViewDistance() < 7 ) ? this.getServer().getViewDistance() : 7 );
-        this.chunkTickList = new gnu.trove.map.hash.TLongShortHashMap( spigotConfig.chunksPerTick * 5, 0.7f, Long.MIN_VALUE, Short.MIN_VALUE );
-        this.chunkTickList.setAutoCompactionFactor( 0 );
+        this.chunkTickRadius = (byte) ((this.getServer().getViewDistance() < 7) ? this.getServer().getViewDistance() : 7);
+        this.chunkTickList = new gnu.trove.map.hash.TLongShortHashMap(spigotConfig.chunksPerTick * 5, 0.7f, Long.MIN_VALUE, Short.MIN_VALUE);
+        this.chunkTickList.setAutoCompactionFactor(0);
         // Spigot end
 
         this.L = this.random.nextInt(12000);
@@ -224,9 +216,11 @@ public abstract class World implements IBlockAccess {
                 getServer().getHandle().sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.SET_WARNING_BLOCKS), World.this);
             }
 
-            public void b(WorldBorder worldborder, double d0) {}
+            public void b(WorldBorder worldborder, double d0) {
+            }
 
-            public void c(WorldBorder worldborder, double d0) {}
+            public void c(WorldBorder worldborder, double d0) {
+            }
         });
         this.getServer().addWorld(this.world);
         // CraftBukkit end
@@ -280,7 +274,6 @@ public abstract class World implements IBlockAccess {
         BlockPosition blockposition1;
 
         for (blockposition1 = new BlockPosition(blockposition.getX(), this.F(), blockposition.getZ()); !this.isEmpty(blockposition1.up()); blockposition1 = blockposition1.up()) {
-            ;
         }
 
         return this.getType(blockposition1).getBlock();
@@ -299,7 +292,7 @@ public abstract class World implements IBlockAccess {
     }
 
     public boolean a(BlockPosition blockposition, boolean flag) {
-        return !this.isValidLocation(blockposition) ? false : this.isChunkLoaded(blockposition.getX() >> 4, blockposition.getZ() >> 4, flag);
+        return this.isValidLocation(blockposition) && this.isChunkLoaded(blockposition.getX() >> 4, blockposition.getZ() >> 4, flag);
     }
 
     public boolean areChunksLoaded(BlockPosition blockposition, int i) {
@@ -481,7 +474,7 @@ public abstract class World implements IBlockAccess {
 
     public void notify(BlockPosition blockposition) {
         for (int i = 0; i < this.u.size(); ++i) {
-            ((IWorldAccess) this.u.get(i)).a(blockposition);
+            this.u.get(i).a(blockposition);
         }
 
     }
@@ -522,7 +515,7 @@ public abstract class World implements IBlockAccess {
 
     public void b(int i, int j, int k, int l, int i1, int j1) {
         for (int k1 = 0; k1 < this.u.size(); ++k1) {
-            ((IWorldAccess) this.u.get(k1)).a(i, j, k, l, i1, j1);
+            this.u.get(k1).a(i, j, k, l, i1, j1);
         }
 
     }
@@ -570,10 +563,10 @@ public abstract class World implements IBlockAccess {
 
             try {
                 // CraftBukkit start
-                CraftWorld world = ((WorldServer) this).getWorld();
-				// TacoSpigot start - Add config to disable redstone firing BlockPhysicsEvent 
-				if (world != null && (this.tacoSpigotConfig.isRedstoneFireBPE || !(block instanceof BlockRedstoneWire || block instanceof BlockRedstoneTorch || block instanceof BlockRepeater))) {
-				// TacoSpigot end
+                CraftWorld world = this.getWorld();
+                // TacoSpigot start - Add config to disable redstone firing BlockPhysicsEvent
+                if (world != null && (this.tacoSpigotConfig.isRedstoneFireBPE || !(block instanceof BlockRedstoneWire || block instanceof BlockRedstoneTorch || block instanceof BlockRepeater))) {
+                    // TacoSpigot end
                     BlockPhysicsEvent event = new BlockPhysicsEvent(world.getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()), CraftMagicNumbers.getId(block));
                     this.getServer().getPluginManager().callEvent(event);
 
@@ -593,7 +586,7 @@ public abstract class World implements IBlockAccess {
                 crashreportsystemdetails.a("Source block type", new Callable() {
                     public String a() throws Exception {
                         try {
-                            return String.format("ID #%d (%s // %s)", new Object[] { Integer.valueOf(Block.getId(block)), block.a(), block.getClass().getCanonicalName()});
+                            return String.format("ID #%d (%s // %s)", Integer.valueOf(Block.getId(block)), block.a(), block.getClass().getCanonicalName());
                         } catch (Throwable throwable) {
                             return "ID #" + Block.getId(block);
                         }
@@ -756,7 +749,7 @@ public abstract class World implements IBlockAccess {
 
     public void n(BlockPosition blockposition) {
         for (int i = 0; i < this.u.size(); ++i) {
-            ((IWorldAccess) this.u.get(i)).b(blockposition);
+            this.u.get(i).b(blockposition);
         }
 
     }
@@ -766,15 +759,14 @@ public abstract class World implements IBlockAccess {
     }
 
     // Spigot start
-    public IBlockData getType(BlockPosition blockposition)
-    {
-        return getType( blockposition, true );
+    public IBlockData getType(BlockPosition blockposition) {
+        return getType(blockposition, true);
     }
 
     public IBlockData getType(BlockPosition blockposition, boolean useCaptured) {
         // CraftBukkit start - tree generation
         if (captureTreeGeneration && useCaptured) {
-    // Spigot end
+            // Spigot end
             Iterator<BlockState> it = capturedBlockStates.iterator();
             while (it.hasNext()) {
                 BlockState previous = it.next();
@@ -944,30 +936,31 @@ public abstract class World implements IBlockAccess {
 
     public void makeSound(Entity entity, String s, float f, float f1) {
         for (int i = 0; i < this.u.size(); ++i) {
-            ((IWorldAccess) this.u.get(i)).a(s, entity.locX, entity.locY, entity.locZ, f, f1);
+            this.u.get(i).a(s, entity.locX, entity.locY, entity.locZ, f, f1);
         }
 
     }
 
     public void a(EntityHuman entityhuman, String s, float f, float f1) {
         for (int i = 0; i < this.u.size(); ++i) {
-            ((IWorldAccess) this.u.get(i)).a(entityhuman, s, entityhuman.locX, entityhuman.locY, entityhuman.locZ, f, f1);
+            this.u.get(i).a(entityhuman, s, entityhuman.locX, entityhuman.locY, entityhuman.locZ, f, f1);
         }
 
     }
 
     public void makeSound(double d0, double d1, double d2, String s, float f, float f1) {
         for (int i = 0; i < this.u.size(); ++i) {
-            ((IWorldAccess) this.u.get(i)).a(s, d0, d1, d2, f, f1);
+            this.u.get(i).a(s, d0, d1, d2, f, f1);
         }
 
     }
 
-    public void a(double d0, double d1, double d2, String s, float f, float f1, boolean flag) {}
+    public void a(double d0, double d1, double d2, String s, float f, float f1, boolean flag) {
+    }
 
     public void a(BlockPosition blockposition, String s) {
         for (int i = 0; i < this.u.size(); ++i) {
-            ((IWorldAccess) this.u.get(i)).a(s, blockposition);
+            this.u.get(i).a(s, blockposition);
         }
 
     }
@@ -978,7 +971,7 @@ public abstract class World implements IBlockAccess {
 
     private void a(int i, boolean flag, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
         for (int j = 0; j < this.u.size(); ++j) {
-            ((IWorldAccess) this.u.get(j)).a(i, flag, d0, d1, d2, d3, d4, d5, aint);
+            this.u.get(j).a(i, flag, d0, d1, d2, d3, d4, d5, aint);
         }
 
     }
@@ -994,7 +987,7 @@ public abstract class World implements IBlockAccess {
     }
 
     public boolean addEntity(Entity entity, SpawnReason spawnReason) { // Changed signature, added SpawnReason
-        org.spigotmc.AsyncCatcher.catchOp( "entity add"); // Spigot
+        org.spigotmc.AsyncCatcher.catchOp("entity add"); // Spigot
         if (entity == null) return false;
         // CraftBukkit end
         int i = MathHelper.floor(entity.locX / 16.0D);
@@ -1069,7 +1062,7 @@ public abstract class World implements IBlockAccess {
 
     protected void a(Entity entity) {
         for (int i = 0; i < this.u.size(); ++i) {
-            ((IWorldAccess) this.u.get(i)).a(entity);
+            this.u.get(i).a(entity);
         }
 
         entity.valid = true; // CraftBukkit
@@ -1077,7 +1070,7 @@ public abstract class World implements IBlockAccess {
 
     protected void b(Entity entity) {
         for (int i = 0; i < this.u.size(); ++i) {
-            ((IWorldAccess) this.u.get(i)).b(entity);
+            this.u.get(i).b(entity);
         }
 
         entity.valid = false; // CraftBukkit
@@ -1085,27 +1078,23 @@ public abstract class World implements IBlockAccess {
 
     public void kill(Entity entity) {
         if (entity.passenger != null) {
-            entity.passenger.mount((Entity) null);
+            entity.passenger.mount(null);
         }
 
         if (entity.vehicle != null) {
-            entity.mount((Entity) null);
+            entity.mount(null);
         }
 
         entity.die();
         if (entity instanceof EntityHuman) {
             this.players.remove(entity);
             // Spigot start
-            for ( Object o : worldMaps.c )
-            {
-                if ( o instanceof WorldMap )
-                {
+            for (Object o : worldMaps.c) {
+                if (o instanceof WorldMap) {
                     WorldMap map = (WorldMap) o;
-                    map.i.remove( entity );
-                    for ( Iterator<WorldMap.WorldMapHumanTracker> iter = (Iterator<WorldMap.WorldMapHumanTracker>) map.g.iterator(); iter.hasNext(); )
-                    {
-                        if ( iter.next().trackee == entity )
-                        {
+                    map.i.remove(entity);
+                    for (Iterator<WorldMap.WorldMapHumanTracker> iter = map.g.iterator(); iter.hasNext(); ) {
+                        if (iter.next().trackee == entity) {
                             iter.remove();
                         }
                     }
@@ -1119,7 +1108,7 @@ public abstract class World implements IBlockAccess {
     }
 
     public void removeEntity(Entity entity) {
-        org.spigotmc.AsyncCatcher.catchOp( "entity remove"); // Spigot
+        org.spigotmc.AsyncCatcher.catchOp("entity remove"); // Spigot
         entity.die();
         if (entity instanceof EntityHuman) {
             this.players.remove(entity);
@@ -1127,22 +1116,22 @@ public abstract class World implements IBlockAccess {
         }
 
         if (!guardEntityList) { // Spigot - It will get removed after the tick if we are ticking
-        int i = entity.ae;
-        int j = entity.ag;
+            int i = entity.ae;
+            int j = entity.ag;
 
-        if (entity.ad && this.isChunkLoaded(i, j, true)) {
-            this.getChunkAt(i, j).b(entity);
-        }
+            if (entity.ad && this.isChunkLoaded(i, j, true)) {
+                this.getChunkAt(i, j).b(entity);
+            }
 
-        // CraftBukkit start - Decrement loop variable field if we've already ticked this entity
-        int index = this.entityList.indexOf(entity);
-        if (index != -1) {
-            if (index <= this.tickPosition) {
-                this.tickPosition--;
+            // CraftBukkit start - Decrement loop variable field if we've already ticked this entity
+            int index = this.entityList.indexOf(entity);
+            if (index != -1) {
+                if (index <= this.tickPosition) {
+                    this.tickPosition--;
+                }
+                this.entityList.remove(index);
             }
-            this.entityList.remove(index);
-        }
-        // CraftBukkit end
+            // CraftBukkit end
         } // Spigot
         this.b(entity);
     }
@@ -1162,19 +1151,14 @@ public abstract class World implements IBlockAccess {
         WorldBorder worldborder = this.getWorldBorder();
         boolean flag = entity.aT();
         boolean flag1 = this.a(worldborder, entity);
-        IBlockData iblockdata = Blocks.STONE.getBlockData();
-        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
 
         // Spigot start
-        int ystart = ( ( k - 1 ) < 0 ) ? 0 : ( k - 1 );
-        for ( int chunkx = ( i >> 4 ); chunkx <= ( ( j - 1 ) >> 4 ); chunkx++ )
-        {
+        int ystart = ((k - 1) < 0) ? 0 : (k - 1);
+        for (int chunkx = (i >> 4); chunkx <= ((j - 1) >> 4); chunkx++) {
             int cx = chunkx << 4;
-            for ( int chunkz = ( i1 >> 4 ); chunkz <= ( ( j1 - 1 ) >> 4 ); chunkz++ )
-            {
-                Chunk chunk = this.getChunkIfLoaded( chunkx, chunkz );
-                if ( chunk == null )
-                {
+            for (int chunkz = (i1 >> 4); chunkz <= ((j1 - 1) >> 4); chunkz++) {
+                Chunk chunk = this.getChunkIfLoaded(chunkx, chunkz);
+                if (chunk == null) {
                     // PaperSpigot start
                     if (entity.loadChunks) {
                         chunk = ((ChunkProviderServer) entity.world.chunkProvider).getChunkAt(chunkx, chunkz);
@@ -1186,18 +1170,15 @@ public abstract class World implements IBlockAccess {
                 }
                 int cz = chunkz << 4;
                 // Compute ranges within chunk
-                int xstart = ( i < cx ) ? cx : i;
-                int xend = ( j < ( cx + 16 ) ) ? j : ( cx + 16 );
-                int zstart = ( i1 < cz ) ? cz : i1;
-                int zend = ( j1 < ( cz + 16 ) ) ? j1 : ( cz + 16 );
+                int xstart = (i < cx) ? cx : i;
+                int xend = (j < (cx + 16)) ? j : (cx + 16);
+                int zstart = (i1 < cz) ? cz : i1;
+                int zend = (j1 < (cz + 16)) ? j1 : (cz + 16);
                 // Loop through blocks within chunk
-                for ( int x = xstart; x < xend; x++ )
-                {
-                    for ( int z = zstart; z < zend; z++ )
-                    {
-                        for ( int y = ystart; y < l; y++ )
-                        {
-                            BlockPosition blockposition = new BlockPosition( x, y, z );
+                for (int x = xstart; x < xend; x++) {
+                    for (int z = zstart; z < zend; z++) {
+                        for (int y = ystart; y < l; y++) {
+                            BlockPosition blockposition = new BlockPosition(x, y, z);
 
                             if (flag && flag1) {
                                 entity.h(false);
@@ -1208,12 +1189,10 @@ public abstract class World implements IBlockAccess {
                             IBlockData block;
                             if (!this.getWorldBorder().a(blockposition) && flag1) {
                                 block = Blocks.STONE.getBlockData();
-                            } else
-                            {
-                                block = chunk.getBlockData( blockposition );
+                            } else {
+                                block = chunk.getBlockData(blockposition);
                             }
-                            if ( block != null )
-                            {
+                            if (block != null) {
                                 // PaperSpigot start - FallingBlocks and TNT collide with specific non-collidable blocks
                                 Block b = block.getBlock();
                                 if (entity.world.paperSpigotConfig.fallingBlocksCollideWithSigns && (entity instanceof EntityTNTPrimed || entity instanceof EntityFallingBlock) && (b instanceof BlockSign || b instanceof BlockFenceGate || b instanceof BlockTorch || b instanceof BlockButtonAbstract || b instanceof BlockLever || b instanceof BlockTripwireHook || b instanceof BlockTripwire || b instanceof BlockChest || b instanceof BlockSlowSand || b instanceof BlockBed || b instanceof BlockEnderChest || b instanceof BlockEnchantmentTable || b instanceof BlockBrewingStand)) {
@@ -1301,7 +1280,7 @@ public abstract class World implements IBlockAccess {
                             iblockdata = Blocks.BEDROCK.getBlockData();
                         }
 
-                        iblockdata.getBlock().a(this, blockposition_mutableblockposition, iblockdata, axisalignedbb, arraylist, (Entity) null);
+                        iblockdata.getBlock().a(this, blockposition_mutableblockposition, iblockdata, axisalignedbb, arraylist, null);
                     }
                 }
             }
@@ -1358,24 +1337,25 @@ public abstract class World implements IBlockAccess {
         return blockposition1;
     }
 
-    public void a(BlockPosition blockposition, Block block, int i) {}
+    public void a(BlockPosition blockposition, Block block, int i) {
+    }
 
-    public void a(BlockPosition blockposition, Block block, int i, int j) {}
+    public void a(BlockPosition blockposition, Block block, int i, int j) {
+    }
 
-    public void b(BlockPosition blockposition, Block block, int i, int j) {}
+    public void b(BlockPosition blockposition, Block block, int i, int j) {
+    }
 
     public void tickEntities() {
         this.methodProfiler.a("entities");
         this.methodProfiler.a("global");
 
         int i;
-        Entity entity;
         CrashReport crashreport;
         CrashReportSystemDetails crashreportsystemdetails;
-
-        for (i = 0; i < this.k.size(); ++i) {
-            entity = (Entity) this.k.get(i);
-            // CraftBukkit start - Fixed an NPE
+        Iterator<Entity> iterator = this.k.iterator();
+        while (iterator.hasNext()) {
+            Entity entity = iterator.next();
             if (entity == null) {
                 continue;
             }
@@ -1388,7 +1368,7 @@ public abstract class World implements IBlockAccess {
                 crashreport = CrashReport.a(throwable, "Ticking entity");
                 crashreportsystemdetails = crashreport.a("Entity being ticked");
                 if (entity == null) {
-                    crashreportsystemdetails.a("Entity", (Object) "~~NULL~~");
+                    crashreportsystemdetails.a("Entity", "~~NULL~~");
                 } else {
                     entity.appendEntityCrashDetails(crashreportsystemdetails);
                 }
@@ -1397,10 +1377,11 @@ public abstract class World implements IBlockAccess {
             }
 
             if (entity.dead) {
-                this.k.remove(i--);
+                iterator.remove();
             }
         }
 
+
         this.methodProfiler.c("remove");
         timings.entityRemoval.startTiming(); // Spigot
         this.entityList.removeAll(this.g);
@@ -1431,13 +1412,12 @@ public abstract class World implements IBlockAccess {
         guardEntityList = true; // Spigot
         // CraftBukkit start - Use field for loop variable
         co.aikar.timings.TimingHistory.entityTicks += this.entityList.size(); // Spigot
-        int entitiesThisCycle = 0;
         // PaperSpigot start - Disable tick limiters
         //if (tickPosition < 0) tickPosition = 0;
         for (tickPosition = 0; tickPosition < entityList.size(); tickPosition++) {
             // PaperSpigot end
             tickPosition = (tickPosition < entityList.size()) ? tickPosition : 0;
-            entity = (Entity) this.entityList.get(this.tickPosition);
+            Entity entity = this.entityList.get(this.tickPosition);
             // CraftBukkit end
             if (entity.vehicle != null) {
                 if (!entity.vehicle.dead && entity.vehicle.passenger == entity) {
@@ -1497,14 +1477,12 @@ public abstract class World implements IBlockAccess {
         // CraftBukkit end
 
         // Spigot start
-        int tilesThisCycle = 0;
         for (tileTickPosition = 0; tileTickPosition < tileEntityList.size(); tileTickPosition++) { // PaperSpigot - Disable tick limiters
             tileTickPosition = (tileTickPosition < tileEntityList.size()) ? tileTickPosition : 0;
-            TileEntity tileentity = (TileEntity) this.tileEntityList.get(tileTickPosition);
+            TileEntity tileentity = this.tileEntityList.get(tileTickPosition);
             // Spigot start
             if (tileentity == null) {
                 getServer().getLogger().severe("Spigot has detected a null entity and has removed it, preventing a crash");
-                tilesThisCycle--;
                 this.tileEntityList.remove(tileTickPosition--);
                 continue;
             }
@@ -1522,7 +1500,6 @@ public abstract class World implements IBlockAccess {
                         tileentity.tickTimer.stopTiming();
                         System.err.println("TileEntity threw exception at " + tileentity.world.getWorld().getName() + ":" + tileentity.position.getX() + "," + tileentity.position.getY() + "," + tileentity.position.getZ());
                         throwable2.printStackTrace();
-                        tilesThisCycle--;
                         this.tileEntityList.remove(tileTickPosition--);
                         continue;
                         // PaperSpigot end
@@ -1536,7 +1513,6 @@ public abstract class World implements IBlockAccess {
             }
 
             if (tileentity.x()) {
-                tilesThisCycle--;
                 this.tileEntityList.remove(tileTickPosition--);
                 //this.h.remove(tileentity); // PaperSpigot - Remove unused list
                 if (this.isLoaded(tileentity.getPosition())) {
@@ -1558,9 +1534,7 @@ public abstract class World implements IBlockAccess {
 
         this.methodProfiler.c("pendingBlockEntities");
         if (!this.b.isEmpty()) {
-            for (int l = 0; l < this.b.size(); ++l) {
-                TileEntity tileentity1 = (TileEntity) this.b.get(l);
-
+            for (TileEntity tileentity1 : this.b) {
                 if (!tileentity1.x()) {
                     /* CraftBukkit start - Order matters, moved down
                     if (!this.h.contains(tileentity1)) {
@@ -1587,24 +1561,19 @@ public abstract class World implements IBlockAccess {
     }
 
     public boolean a(TileEntity tileentity) {
-        boolean flag = true; // PaperSpigot - Remove unused list
-
-        if (flag && tileentity instanceof IUpdatePlayerListBox) {
+        if (tileentity instanceof IUpdatePlayerListBox) {
             this.tileEntityList.add(tileentity);
         }
 
-        return flag;
+        return true;
     }
 
     public void a(Collection<TileEntity> collection) {
         if (this.M) {
             this.b.addAll(collection);
         } else {
-            Iterator iterator = collection.iterator();
-
-            while (iterator.hasNext()) {
-                TileEntity tileentity = (TileEntity) iterator.next();
 
+            for (TileEntity tileentity : collection) {
                 //this.h.add(tileentity); // PaperSpigot - Remove unused list
                 if (tileentity instanceof IUpdatePlayerListBox) {
                     this.tileEntityList.add(tileentity);
@@ -1621,7 +1590,6 @@ public abstract class World implements IBlockAccess {
     public void entityJoinedWorld(Entity entity, boolean flag) {
         int i = MathHelper.floor(entity.locX);
         int j = MathHelper.floor(entity.locZ);
-        byte b0 = 32;
 
         // Spigot start
         if (!org.spigotmc.ActivationRange.checkIfActive(entity)) {
@@ -1709,7 +1677,7 @@ public abstract class World implements IBlockAccess {
     }
 
     public boolean a(AxisAlignedBB axisalignedbb, Entity entity) {
-        List list = this.getEntities((Entity) null, axisalignedbb);
+        List list = this.getEntities(null, axisalignedbb);
 
         for (int i = 0; i < list.size(); ++i) {
             Entity entity1 = (Entity) list.get(i);
@@ -1827,7 +1795,7 @@ public abstract class World implements IBlockAccess {
                         Block block = iblockdata.getBlock();
 
                         if (block.getMaterial() == material) {
-                            double d0 = (double) ((float) (l1 + 1) - BlockFluids.b(((Integer) iblockdata.get(BlockFluids.LEVEL)).intValue()));
+                            double d0 = (double) ((float) (l1 + 1) - BlockFluids.b(iblockdata.get(BlockFluids.LEVEL).intValue()));
 
                             if ((double) l >= d0) {
                                 flag = true;
@@ -1889,7 +1857,7 @@ public abstract class World implements IBlockAccess {
                     Block block = iblockdata.getBlock();
 
                     if (block.getMaterial() == material) {
-                        int j2 = ((Integer) iblockdata.get(BlockFluids.LEVEL)).intValue();
+                        int j2 = iblockdata.get(BlockFluids.LEVEL).intValue();
                         double d0 = (double) (l1 + 1);
 
                         if (j2 < 8) {
@@ -1981,7 +1949,7 @@ public abstract class World implements IBlockAccess {
 
             if (this.M) {
                 for (i = 0; i < this.b.size(); ++i) {
-                    tileentity1 = (TileEntity) this.b.get(i);
+                    tileentity1 = this.b.get(i);
                     if (!tileentity1.x() && tileentity1.getPosition().equals(blockposition)) {
                         tileentity = tileentity1;
                         break;
@@ -1995,7 +1963,7 @@ public abstract class World implements IBlockAccess {
 
             if (tileentity == null) {
                 for (i = 0; i < this.b.size(); ++i) {
-                    tileentity1 = (TileEntity) this.b.get(i);
+                    tileentity1 = this.b.get(i);
                     if (!tileentity1.x() && tileentity1.getPosition().equals(blockposition)) {
                         tileentity = tileentity1;
                         break;
@@ -2073,7 +2041,7 @@ public abstract class World implements IBlockAccess {
         IBlockData iblockdata = iblockaccess.getType(blockposition);
         Block block = iblockdata.getBlock();
 
-        return block.getMaterial().k() && block.d() ? true : (block instanceof BlockStairs ? iblockdata.get(BlockStairs.HALF) == BlockStairs.EnumHalf.TOP : (block instanceof BlockStepAbstract ? iblockdata.get(BlockStepAbstract.HALF) == BlockStepAbstract.EnumSlabHalf.TOP : (block instanceof BlockHopper ? true : (block instanceof BlockSnow ? ((Integer) iblockdata.get(BlockSnow.LAYERS)).intValue() == 7 : false))));
+        return block.getMaterial().k() && block.d() || (block instanceof BlockStairs ? iblockdata.get(BlockStairs.HALF) == BlockStairs.EnumHalf.TOP : (block instanceof BlockStepAbstract ? iblockdata.get(BlockStepAbstract.HALF) == BlockStepAbstract.EnumSlabHalf.TOP : (block instanceof BlockHopper || (block instanceof BlockSnow && iblockdata.get(BlockSnow.LAYERS).intValue() == 7))));
     }
 
     public boolean d(BlockPosition blockposition, boolean flag) {
@@ -2205,38 +2173,36 @@ public abstract class World implements IBlockAccess {
         // Spigot start
         int optimalChunks = spigotConfig.chunksPerTick;
         // Quick conditions to allow us to exist early
-        if ( optimalChunks > 0  ) {
-        // Keep chunks with growth inside of the optimal chunk range
-        int chunksPerPlayer = Math.min( 200, Math.max( 1, (int) ( ( ( optimalChunks - players.size() ) / (double) players.size() ) + 0.5 ) ) );
-        int randRange = 3 + chunksPerPlayer / 30;
-        // Limit to normal tick radius - including view distance
-        randRange = ( randRange > chunkTickRadius ) ? chunkTickRadius : randRange;
-        // odds of growth happening vs growth happening in vanilla
-        this.growthOdds = this.modifiedOdds = Math.max( 35, Math.min( 100, ( ( chunksPerPlayer + 1 ) * 100F ) / 15F ) );
-        // Spigot end
-        for (i = 0; i < this.players.size(); ++i) {
-            entityhuman = (EntityHuman) this.players.get(i);
-            j = MathHelper.floor(entityhuman.locX / 16.0D);
-            k = MathHelper.floor(entityhuman.locZ / 16.0D);
-            l = this.q();
-
-            // Spigot start - Always update the chunk the player is on
-            long key = chunkToKey( j, k );
-            int existingPlayers = Math.max( 0, chunkTickList.get( key ) ); // filter out -1
-            chunkTickList.put( key, (short) ( existingPlayers + 1 ) );
-
-            // Check and see if we update the chunks surrounding the player this tick
-            for ( int chunk = 0; chunk < chunksPerPlayer; chunk++ )
-            {
-                int dx = ( random.nextBoolean() ? 1 : -1 ) * random.nextInt( randRange );
-                int dz = ( random.nextBoolean() ? 1 : -1 ) * random.nextInt( randRange );
-                long hash = chunkToKey( dx + j, dz + k );
-                if ( !chunkTickList.contains( hash ) && this.chunkProvider.isChunkLoaded(dx + j, dz + k ) )
-                {
-                    chunkTickList.put( hash, (short) -1 ); // no players
+        if (optimalChunks > 0) {
+            // Keep chunks with growth inside of the optimal chunk range
+            int chunksPerPlayer = Math.min(200, Math.max(1, (int) (((optimalChunks - players.size()) / (double) players.size()) + 0.5)));
+            int randRange = 3 + chunksPerPlayer / 30;
+            // Limit to normal tick radius - including view distance
+            randRange = (randRange > chunkTickRadius) ? chunkTickRadius : randRange;
+            // odds of growth happening vs growth happening in vanilla
+            this.growthOdds = this.modifiedOdds = Math.max(35, Math.min(100, ((chunksPerPlayer + 1) * 100F) / 15F));
+            // Spigot end
+            for (i = 0; i < this.players.size(); ++i) {
+                entityhuman = this.players.get(i);
+                j = MathHelper.floor(entityhuman.locX / 16.0D);
+                k = MathHelper.floor(entityhuman.locZ / 16.0D);
+                l = this.q();
+
+                // Spigot start - Always update the chunk the player is on
+                long key = chunkToKey(j, k);
+                int existingPlayers = Math.max(0, chunkTickList.get(key)); // filter out -1
+                chunkTickList.put(key, (short) (existingPlayers + 1));
+
+                // Check and see if we update the chunks surrounding the player this tick
+                for (int chunk = 0; chunk < chunksPerPlayer; chunk++) {
+                    int dx = (random.nextBoolean() ? 1 : -1) * random.nextInt(randRange);
+                    int dz = (random.nextBoolean() ? 1 : -1) * random.nextInt(randRange);
+                    long hash = chunkToKey(dx + j, dz + k);
+                    if (!chunkTickList.contains(hash) && this.chunkProvider.isChunkLoaded(dx + j, dz + k)) {
+                        chunkTickList.put(hash, (short) -1); // no players
+                    }
                 }
             }
-        }
             // Spigot End
         }
 
@@ -2248,7 +2214,7 @@ public abstract class World implements IBlockAccess {
         this.methodProfiler.a("playerCheckLight");
         if (spigotConfig.randomLightUpdates && !this.players.isEmpty()) { // Spigot
             i = this.random.nextInt(this.players.size());
-            entityhuman = (EntityHuman) this.players.get(i);
+            entityhuman = this.players.get(i);
             j = MathHelper.floor(entityhuman.locX) + this.random.nextInt(11) - 5;
             k = MathHelper.floor(entityhuman.locY) + this.random.nextInt(11) - 5;
             l = MathHelper.floor(entityhuman.locZ) + this.random.nextInt(11) - 5;
@@ -2316,16 +2282,14 @@ public abstract class World implements IBlockAccess {
                 IBlockData iblockdata = this.getType(blockposition);
                 Block block = iblockdata.getBlock();
 
-                if ((block == Blocks.WATER || block == Blocks.FLOWING_WATER) && ((Integer) iblockdata.get(BlockFluids.LEVEL)).intValue() == 0) {
+                if ((block == Blocks.WATER || block == Blocks.FLOWING_WATER) && iblockdata.get(BlockFluids.LEVEL).intValue() == 0) {
                     if (!flag) {
                         return true;
                     }
 
                     boolean flag1 = this.F(blockposition.west()) && this.F(blockposition.east()) && this.F(blockposition.north()) && this.F(blockposition.south());
 
-                    if (!flag1) {
-                        return true;
-                    }
+                    return !flag1;
                 }
             }
 
@@ -2349,9 +2313,7 @@ public abstract class World implements IBlockAccess {
             if (blockposition.getY() >= 0 && blockposition.getY() < 256 && this.b(EnumSkyBlock.BLOCK, blockposition) < 10) {
                 Block block = this.getType(blockposition).getBlock();
 
-                if (block.getMaterial() == Material.AIR && Blocks.SNOW_LAYER.canPlace(this, blockposition)) {
-                    return true;
-                }
+                return block.getMaterial() == Material.AIR && Blocks.SNOW_LAYER.canPlace(this, blockposition);
             }
 
             return false;
@@ -2471,7 +2433,7 @@ public abstract class World implements IBlockAccess {
                                     blockposition_mutableblockposition.c(k4, l4, i5);
                                     int j5 = Math.max(1, this.getType(blockposition_mutableblockposition).getBlock().p());
 
-                                    l2 = this.b(enumskyblock, (BlockPosition) blockposition_mutableblockposition);
+                                    l2 = this.b(enumskyblock, blockposition_mutableblockposition);
                                     if (l2 == l3 - j5 && j < this.H.length) {
                                         this.H[j++] = k4 - i1 + 32 | l4 - j1 + 32 << 6 | i5 - k1 + 32 << 12 | l3 - j5 << 18;
                                     }
@@ -2701,7 +2663,7 @@ public abstract class World implements IBlockAccess {
     }
 
     public Entity a(int i) {
-        return (Entity) this.entitiesById.get(i);
+        return this.entitiesById.get(i);
     }
 
     public void b(BlockPosition blockposition, TileEntity tileentity) {
@@ -2726,7 +2688,7 @@ public abstract class World implements IBlockAccess {
             }
 
             if (oclass.isAssignableFrom(entity.getClass())) {
-            // if ((!(entity instanceof EntityInsentient) || !((EntityInsentient) entity).isPersistent()) && oclass.isAssignableFrom(entity.getClass())) {
+                // if ((!(entity instanceof EntityInsentient) || !((EntityInsentient) entity).isPersistent()) && oclass.isAssignableFrom(entity.getClass())) {
                 // CraftBukkit end
                 ++i;
             }
@@ -2736,7 +2698,7 @@ public abstract class World implements IBlockAccess {
     }
 
     public void b(Collection<Entity> collection) {
-        org.spigotmc.AsyncCatcher.catchOp( "entity world add"); // Spigot
+        org.spigotmc.AsyncCatcher.catchOp("entity world add"); // Spigot
         // CraftBukkit start
         // this.entityList.addAll(collection);
         Iterator iterator = collection.iterator();
@@ -2763,7 +2725,7 @@ public abstract class World implements IBlockAccess {
         AxisAlignedBB axisalignedbb = flag ? null : block.a(this, blockposition, block.getBlockData());
 
         // CraftBukkit start - store default return
-        boolean defaultReturn = axisalignedbb != null && !this.a(axisalignedbb, entity) ? false : (block1.getMaterial() == Material.ORIENTABLE && block == Blocks.ANVIL ? true : block1.getMaterial().isReplaceable() && block.canPlace(this, blockposition, enumdirection, itemstack));
+        boolean defaultReturn = (axisalignedbb == null || this.a(axisalignedbb, entity)) && (block1.getMaterial() == Material.ORIENTABLE && block == Blocks.ANVIL || block1.getMaterial().isReplaceable() && block.canPlace(this, blockposition, enumdirection, itemstack));
         BlockCanBuildEvent event = new BlockCanBuildEvent(this.getWorld().getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()), CraftMagicNumbers.getId(block), defaultReturn);
         this.getServer().getPluginManager().callEvent(event);
 
@@ -2782,7 +2744,7 @@ public abstract class World implements IBlockAccess {
     public int getBlockPower(BlockPosition blockposition, EnumDirection enumdirection) {
         IBlockData iblockdata = this.getType(blockposition);
 
-        return iblockdata.getBlock().b((IBlockAccess) this, blockposition, iblockdata, enumdirection);
+        return iblockdata.getBlock().b(this, blockposition, iblockdata, enumdirection);
     }
 
     public WorldType G() {
@@ -2829,11 +2791,11 @@ public abstract class World implements IBlockAccess {
         IBlockData iblockdata = this.getType(blockposition);
         Block block = iblockdata.getBlock();
 
-        return block.isOccluding() ? this.getBlockPower(blockposition) : block.a((IBlockAccess) this, blockposition, iblockdata, enumdirection);
+        return block.isOccluding() ? this.getBlockPower(blockposition) : block.a(this, blockposition, iblockdata, enumdirection);
     }
 
     public boolean isBlockIndirectlyPowered(BlockPosition blockposition) {
-        return this.getBlockFacePower(blockposition.down(), EnumDirection.DOWN) > 0 ? true : (this.getBlockFacePower(blockposition.up(), EnumDirection.UP) > 0 ? true : (this.getBlockFacePower(blockposition.north(), EnumDirection.NORTH) > 0 ? true : (this.getBlockFacePower(blockposition.south(), EnumDirection.SOUTH) > 0 ? true : (this.getBlockFacePower(blockposition.west(), EnumDirection.WEST) > 0 ? true : this.getBlockFacePower(blockposition.east(), EnumDirection.EAST) > 0))));
+        return this.getBlockFacePower(blockposition.down(), EnumDirection.DOWN) > 0 || (this.getBlockFacePower(blockposition.up(), EnumDirection.UP) > 0 || (this.getBlockFacePower(blockposition.north(), EnumDirection.NORTH) > 0 || (this.getBlockFacePower(blockposition.south(), EnumDirection.SOUTH) > 0 || (this.getBlockFacePower(blockposition.west(), EnumDirection.WEST) > 0 || this.getBlockFacePower(blockposition.east(), EnumDirection.EAST) > 0))));
     }
 
     public int A(BlockPosition blockposition) {
@@ -2866,7 +2828,7 @@ public abstract class World implements IBlockAccess {
         EntityHuman entityhuman = null;
 
         for (int i = 0; i < this.players.size(); ++i) {
-            EntityHuman entityhuman1 = (EntityHuman) this.players.get(i);
+            EntityHuman entityhuman1 = this.players.get(i);
             // CraftBukkit start - Fixed an NPE
             if (entityhuman1 == null || entityhuman1.dead) {
                 continue;
@@ -2888,7 +2850,7 @@ public abstract class World implements IBlockAccess {
 
     public boolean isPlayerNearby(double d0, double d1, double d2, double d3) {
         for (int i = 0; i < this.players.size(); ++i) {
-            EntityHuman entityhuman = (EntityHuman) this.players.get(i);
+            EntityHuman entityhuman = this.players.get(i);
 
             if (IEntitySelector.d.apply(entityhuman)) {
                 double d4 = entityhuman.e(d0, d1, d2);
@@ -2912,7 +2874,7 @@ public abstract class World implements IBlockAccess {
         EntityHuman entityhuman = null;
 
         for (int i = 0; i < this.players.size(); ++i) {
-            EntityHuman entityhuman1 = (EntityHuman) this.players.get(i);
+            EntityHuman entityhuman1 = this.players.get(i);
             // CraftBukkit start - Fixed an NPE
             if (entityhuman1 == null || entityhuman1.dead || !entityhuman1.affectsSpawning) {
                 continue;
@@ -2934,7 +2896,7 @@ public abstract class World implements IBlockAccess {
 
     public boolean isPlayerNearbyWhoAffectsSpawning(double d0, double d1, double d2, double d3) {
         for (int i = 0; i < this.players.size(); ++i) {
-            EntityHuman entityhuman = (EntityHuman) this.players.get(i);
+            EntityHuman entityhuman = this.players.get(i);
 
             if (IEntitySelector.d.apply(entityhuman)) {
                 double d4 = entityhuman.e(d0, d1, d2);
@@ -2951,7 +2913,7 @@ public abstract class World implements IBlockAccess {
 
     public EntityHuman a(String s) {
         for (int i = 0; i < this.players.size(); ++i) {
-            EntityHuman entityhuman = (EntityHuman) this.players.get(i);
+            EntityHuman entityhuman = this.players.get(i);
 
             if (s.equals(entityhuman.getName())) {
                 return entityhuman;
@@ -2963,7 +2925,7 @@ public abstract class World implements IBlockAccess {
 
     public EntityHuman b(UUID uuid) {
         for (int i = 0; i < this.players.size(); ++i) {
-            EntityHuman entityhuman = (EntityHuman) this.players.get(i);
+            EntityHuman entityhuman = this.players.get(i);
 
             if (uuid.equals(entityhuman.getUniqueID())) {
                 return entityhuman;
@@ -3011,7 +2973,8 @@ public abstract class World implements IBlockAccess {
         return true;
     }
 
-    public void broadcastEntityEffect(Entity entity, byte b0) {}
+    public void broadcastEntityEffect(Entity entity, byte b0) {
+    }
 
     public IChunkProvider N() {
         return this.chunkProvider;
@@ -3033,7 +2996,8 @@ public abstract class World implements IBlockAccess {
         return this.worldData.x();
     }
 
-    public void everyoneSleeping() {}
+    public void everyoneSleeping() {
+    }
 
     // CraftBukkit start
     // Calls the method that checks to see if players are sleeping
@@ -3071,7 +3035,7 @@ public abstract class World implements IBlockAccess {
         } else {
             BiomeBase biomebase = this.getBiome(blockposition);
 
-            return biomebase.d() ? false : (this.f(blockposition, false) ? false : biomebase.e());
+            return !biomebase.d() && (!this.f(blockposition, false) && biomebase.e());
         }
     }
 
@@ -3099,29 +3063,29 @@ public abstract class World implements IBlockAccess {
 
     public void a(int i, BlockPosition blockposition, int j) {
         for (int k = 0; k < this.u.size(); ++k) {
-            ((IWorldAccess) this.u.get(k)).a(i, blockposition, j);
+            this.u.get(k).a(i, blockposition, j);
         }
 
     }
 
     public void triggerEffect(int i, BlockPosition blockposition, int j) {
-        this.a((EntityHuman) null, i, blockposition, j);
+        this.a(null, i, blockposition, j);
     }
 
     public void a(EntityHuman entityhuman, int i, BlockPosition blockposition, int j) {
         try {
             for (int k = 0; k < this.u.size(); ++k) {
-                ((IWorldAccess) this.u.get(k)).a(entityhuman, i, blockposition, j);
+                this.u.get(k).a(entityhuman, i, blockposition, j);
             }
 
         } catch (Throwable throwable) {
             CrashReport crashreport = CrashReport.a(throwable, "Playing level event");
             CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Level event being played");
 
-            crashreportsystemdetails.a("Block coordinates", (Object) CrashReportSystemDetails.a(blockposition));
-            crashreportsystemdetails.a("Event source", (Object) entityhuman);
-            crashreportsystemdetails.a("Event type", (Object) Integer.valueOf(i));
-            crashreportsystemdetails.a("Event data", (Object) Integer.valueOf(j));
+            crashreportsystemdetails.a("Block coordinates", CrashReportSystemDetails.a(blockposition));
+            crashreportsystemdetails.a("Event source", entityhuman);
+            crashreportsystemdetails.a("Event type", Integer.valueOf(i));
+            crashreportsystemdetails.a("Event data", Integer.valueOf(j));
             throw new ReportedException(crashreport);
         }
     }
@@ -3148,7 +3112,7 @@ public abstract class World implements IBlockAccess {
     public CrashReportSystemDetails a(CrashReport crashreport) {
         CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Affected level", 1);
 
-        crashreportsystemdetails.a("Level name", (Object) (this.worldData == null ? "????" : this.worldData.getName()));
+        crashreportsystemdetails.a("Level name", this.worldData == null ? "????" : this.worldData.getName());
         crashreportsystemdetails.a("All players", new Callable() {
             public String a() {
                 return World.this.players.size() + " total; " + World.this.players.toString();
@@ -3179,7 +3143,7 @@ public abstract class World implements IBlockAccess {
 
     public void c(int i, BlockPosition blockposition, int j) {
         for (int k = 0; k < this.u.size(); ++k) {
-            IWorldAccess iworldaccess = (IWorldAccess) this.u.get(k);
+            IWorldAccess iworldaccess = this.u.get(k);
 
             iworldaccess.b(i, blockposition, j);
         }
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index 40a066ca5..2f7fbb20b 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -3,30 +3,22 @@ package net.minecraft.server;
 import com.google.common.base.Predicate;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
-import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Random;
-import java.util.Set;
-import java.util.TreeSet;
-import java.util.UUID;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
-
-// CraftBukkit start
-import java.util.*;
-import java.util.logging.Level;
-
 import org.bukkit.WeatherType;
 import org.bukkit.block.BlockState;
-import org.bukkit.craftbukkit.util.LongHash;
 import org.bukkit.craftbukkit.util.HashTreeSet;
-
+import org.bukkit.craftbukkit.util.LongHash;
 import org.bukkit.event.block.BlockFormEvent;
 import org.bukkit.event.weather.LightningStrikeEvent;
+
+import java.util.*;
+import java.util.logging.Level;
+
+// CraftBukkit start
+
+// CraftBukkit start
 // CraftBukkit end
 
 public class WorldServer extends World implements IAsyncTaskHandler {
@@ -45,9 +37,9 @@ public class WorldServer extends World implements IAsyncTaskHandler {
     private final PortalTravelAgent Q;
     private final SpawnerCreature R = new SpawnerCreature();
     protected final VillageSiege siegeManager = new VillageSiege(this);
-    private WorldServer.BlockActionDataList[] S = new WorldServer.BlockActionDataList[] { new WorldServer.BlockActionDataList(null), new WorldServer.BlockActionDataList(null)};
+    private WorldServer.BlockActionDataList[] S = new WorldServer.BlockActionDataList[]{new WorldServer.BlockActionDataList(null), new WorldServer.BlockActionDataList(null)};
     private int T;
-    private static final List<StructurePieceTreasure> U = Lists.newArrayList(new StructurePieceTreasure[] { new StructurePieceTreasure(Items.STICK, 0, 1, 3, 10), new StructurePieceTreasure(Item.getItemOf(Blocks.PLANKS), 0, 1, 3, 10), new StructurePieceTreasure(Item.getItemOf(Blocks.LOG), 0, 1, 3, 10), new StructurePieceTreasure(Items.STONE_AXE, 0, 1, 1, 3), new StructurePieceTreasure(Items.WOODEN_AXE, 0, 1, 1, 5), new StructurePieceTreasure(Items.STONE_PICKAXE, 0, 1, 1, 3), new StructurePieceTreasure(Items.WOODEN_PICKAXE, 0, 1, 1, 5), new StructurePieceTreasure(Items.APPLE, 0, 2, 3, 5), new StructurePieceTreasure(Items.BREAD, 0, 2, 3, 3), new StructurePieceTreasure(Item.getItemOf(Blocks.LOG2), 0, 1, 3, 10)});
+    private static final List<StructurePieceTreasure> U = Lists.newArrayList(new StructurePieceTreasure[]{new StructurePieceTreasure(Items.STICK, 0, 1, 3, 10), new StructurePieceTreasure(Item.getItemOf(Blocks.PLANKS), 0, 1, 3, 10), new StructurePieceTreasure(Item.getItemOf(Blocks.LOG), 0, 1, 3, 10), new StructurePieceTreasure(Items.STONE_AXE, 0, 1, 1, 3), new StructurePieceTreasure(Items.WOODEN_AXE, 0, 1, 1, 5), new StructurePieceTreasure(Items.STONE_PICKAXE, 0, 1, 1, 3), new StructurePieceTreasure(Items.WOODEN_PICKAXE, 0, 1, 1, 5), new StructurePieceTreasure(Items.APPLE, 0, 2, 3, 5), new StructurePieceTreasure(Items.BREAD, 0, 2, 3, 3), new StructurePieceTreasure(Item.getItemOf(Blocks.LOG2), 0, 1, 3, 10)});
     private List<NextTickListEntry> V = Lists.newArrayList();
 
     // CraftBukkit start
@@ -85,17 +77,17 @@ public class WorldServer extends World implements IAsyncTaskHandler {
         }
 
         if (getServer().getScoreboardManager() == null) { // CraftBukkit
-        this.scoreboard = new ScoreboardServer(this.server);
-        PersistentScoreboard persistentscoreboard = (PersistentScoreboard) this.worldMaps.get(PersistentScoreboard.class, "scoreboard");
+            this.scoreboard = new ScoreboardServer(this.server);
+            PersistentScoreboard persistentscoreboard = (PersistentScoreboard) this.worldMaps.get(PersistentScoreboard.class, "scoreboard");
 
-        if (persistentscoreboard == null) {
-            persistentscoreboard = new PersistentScoreboard();
-            this.worldMaps.a("scoreboard", persistentscoreboard);
-        }
+            if (persistentscoreboard == null) {
+                persistentscoreboard = new PersistentScoreboard();
+                this.worldMaps.a("scoreboard", persistentscoreboard);
+            }
 
-        persistentscoreboard.a(this.scoreboard);
-        ((ScoreboardServer) this.scoreboard).a(persistentscoreboard);
-        // CraftBukkit start
+            persistentscoreboard.a(this.scoreboard);
+            ((ScoreboardServer) this.scoreboard).a(persistentscoreboard);
+            // CraftBukkit start
         } else {
             this.scoreboard = getServer().getScoreboardManager().getMainScoreboard().getHandle();
         }
@@ -375,13 +367,13 @@ public class WorldServer extends World implements IAsyncTaskHandler {
         super.h();
         if (this.worldData.getType() == WorldType.DEBUG_ALL_BLOCK_STATES) {
             // Spigot start
-           gnu.trove.iterator.TLongShortIterator iterator = this.chunkTickList.iterator();
+            gnu.trove.iterator.TLongShortIterator iterator = this.chunkTickList.iterator();
 
             while (iterator.hasNext()) {
                 iterator.advance();
                 long chunkCoord = iterator.key();
 
-                this.getChunkAt(World.keyToX( chunkCoord ), World.keyToZ( chunkCoord )).b(false);
+                this.getChunkAt(World.keyToX(chunkCoord), World.keyToZ(chunkCoord)).b(false);
                 // Spigot end
             }
 
@@ -395,14 +387,13 @@ public class WorldServer extends World implements IAsyncTaskHandler {
             //    int k = chunkcoordintpair1.x * 16;
             //    int l = chunkcoordintpair1.z * 16;
             // Spigot start
-            for (gnu.trove.iterator.TLongShortIterator iter = chunkTickList.iterator(); iter.hasNext(); )
-            {
+            for (gnu.trove.iterator.TLongShortIterator iter = chunkTickList.iterator(); iter.hasNext(); ) {
                 iter.advance();
                 long chunkCoord = iter.key();
-                int chunkX = World.keyToX( chunkCoord );
-                int chunkZ = World.keyToZ( chunkCoord );
+                int chunkX = World.keyToX(chunkCoord);
+                int chunkZ = World.keyToZ(chunkCoord);
                 // If unloaded, or in procedd of being unloaded, drop it
-                if ( ( !this.chunkProvider.isChunkLoaded( chunkX, chunkZ ) ) || ( this.chunkProviderServer.unloadQueue.contains( LongHash.toLong(chunkX, chunkZ) ) ) ) // TacoSpigot - invoke LongHash directly
+                if ((!this.chunkProvider.isChunkLoaded(chunkX, chunkZ)) || (this.chunkProviderServer.unloadQueue.contains(LongHash.toLong(chunkX, chunkZ)))) // TacoSpigot - invoke LongHash directly
                 {
                     iter.remove();
                     continue;
@@ -505,8 +496,7 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 
         }
         // Spigot Start
-        if ( spigotConfig.clearChunksOnTick )
-        {
+        if (spigotConfig.clearChunksOnTick) {
             chunkTickList.clear();
         }
         // Spigot End
@@ -1102,11 +1092,8 @@ public class WorldServer extends World implements IAsyncTaskHandler {
             int i = this.T;
 
             this.T ^= 1;
-            Iterator iterator = this.S[i].iterator();
-
-            while (iterator.hasNext()) {
-                BlockActionData blockactiondata = (BlockActionData) iterator.next();
 
+            for (BlockActionData blockactiondata : this.S[i]) {
                 if (this.a(blockactiondata)) {
                     // CraftBukkit - this.worldProvider.dimension -> this.dimension
                     this.server.getPlayerList().sendPacketNearby((double) blockactiondata.a().getX(), (double) blockactiondata.a().getY(), (double) blockactiondata.a().getZ(), 64.0D, dimension, new PacketPlayOutBlockAction(blockactiondata.a(), blockactiondata.d(), blockactiondata.b(), blockactiondata.c()));
@@ -1121,7 +1108,7 @@ public class WorldServer extends World implements IAsyncTaskHandler {
     private boolean a(BlockActionData blockactiondata) {
         IBlockData iblockdata = this.getType(blockactiondata.a());
 
-        return iblockdata.getBlock() == blockactiondata.d() ? iblockdata.getBlock().a(this, blockactiondata.a(), iblockdata, blockactiondata.b(), blockactiondata.c()) : false;
+        return iblockdata.getBlock() == blockactiondata.d() && iblockdata.getBlock().a(this, blockactiondata.a(), iblockdata, blockactiondata.b(), blockactiondata.c());
     }
 
     public void saveLevel() {
@@ -1154,15 +1141,15 @@ public class WorldServer extends World implements IAsyncTaskHandler {
         // */
         if (flag != this.S()) {
             // Only send weather packets to those affected
-            for (int i = 0; i < this.players.size(); ++i) {
-                if (((EntityPlayer) this.players.get(i)).world == this) {
-                    ((EntityPlayer) this.players.get(i)).setPlayerWeather((!flag ? WeatherType.DOWNFALL : WeatherType.CLEAR), false);
+            for (EntityHuman player : this.players) {
+                if (((EntityPlayer) player).world == this) {
+                    ((EntityPlayer) player).setPlayerWeather((!flag ? WeatherType.DOWNFALL : WeatherType.CLEAR), false);
                 }
             }
         }
-        for (int i = 0; i < this.players.size(); ++i) {
-            if (((EntityPlayer) this.players.get(i)).world == this) {
-                ((EntityPlayer) this.players.get(i)).updateWeather(this.o, this.p, this.q, this.r);
+        for (EntityHuman player : this.players) {
+            if (((EntityPlayer) player).world == this) {
+                ((EntityPlayer) player).updateWeather(this.o, this.p, this.q, this.r);
             }
         }
         // CraftBukkit end
@@ -1204,7 +1191,8 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 
         for (int j = 0; j < this.players.size(); ++j) {
             EntityPlayer entityplayer = (EntityPlayer) this.players.get(j);
-            if (sender != null && !entityplayer.getBukkitEntity().canSee(sender.getBukkitEntity())) continue; // CraftBukkit
+            if (sender != null && !entityplayer.getBukkitEntity().canSee(sender.getBukkitEntity()))
+                continue; // CraftBukkit
             BlockPosition blockposition = entityplayer.getChunkCoordinates();
             double d7 = blockposition.c(d0, d1, d2);
 
@@ -1229,7 +1217,8 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 
     static class BlockActionDataList extends ArrayList<BlockActionData> {
 
-        private BlockActionDataList() {}
+        private BlockActionDataList() {
+        }
 
         BlockActionDataList(Object object) {
             this();
-- 
2.21.0.windows.1

